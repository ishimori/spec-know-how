# 実装マニュアル — リエンジニアリングにおける構築フェーズガイド

> **対象フェーズ**: 垂直スライス → 核機能実装 → 放射的実装 → 品質ゲート → 拡張・デプロイ（コードを書く全工程）
> **本書の位置づけ**: プロジェクト固有情報を排除した汎用版（分家）
> **完全版**: 本マニュアルは実プロジェクトの実践経験から抽出したものです。具体的なDD番号・数値データを含む完全版は、プロジェクト内の `doc/リエンジニアリング手法/03_実践マニュアル/02_実装マニュアル.md` を参照してください。
> **前提**: 本書は `01_仕様書作成マニュアル.md` の5ステップを完了し、全仕様書が [VERIFIED] であることを前提とする

---

## 1. 概要

### 1.1 このマニュアルの目的

仕様書が完成した後、**新システムを段階的に構築し、品質を担保しながら本番デプロイに到達する**ための手順書。

仕様書作成マニュアルが「Quality In」を担保するのに対し、本書は「Quality Through」— 構築プロセスの中で品質を積み上げる方法を定義する。実装の**順序**と**品質ゲートの配置**が、仕様書の品質と同等に重要である。

### 1.2 前提条件

- 仕様書作成マニュアルの Gate 0〜4（全5ステップ）を全てクリアしていること
- 全仕様書が `[VERIFIED]` であること
- DB設計・アーキテクチャ設計が完了していること
- 技術スタックが確定していること
- DA批判レビューの義務化が合意されていること

> **Gate 番号の対応**: 本書（実装マニュアル）は Gate 1〜5、仕様書作成マニュアルは Gate 0〜4 を使用する。両者は別の工程であり、番号は独立している。

### 1.3 全体の流れ

本マニュアルは5つのステップで構成される。各ステップには**ゲート（通過基準）**が定義されており、ゲートを通過しない限り次の品質ステップに進んではならない。ただし、デプロイ活動（Step 5）は早期フィードバックのため Step 3 中盤から並行して開始する（詳細は後述）。

```
Step 1: 垂直スライス        全レイヤーの技術疎通を最小機能で確認
    │  Gate 1: 全レイヤー疎通 + DA通過
    ▼
Step 2: 核機能の実装        最も複雑な機能を3分割パターンで構築
    │  Gate 2: 核機能の画面間不整合レビュー通過
    ▼
Step 3: 放射的実装          核機能から依存画面群を展開
    │  Gate 3: 横断DA分析通過
    │            ┌──────────────────────────────────┐
    │            │ ※ デプロイは Step 3 中盤（40-60%   │
    │            │   完成時）から Step 5 と並行開始    │
    │            └──────────────────────────────────┘
    ▼
Step 4: 品質ゲート          横断バグハント・ログ整備・技術負債トリアージ
    │  Gate 4: HIGH issues = 0、ログ基盤稼働中
    ▼
Step 5: 拡張・テスト・デプロイ  UI改善、テスト基盤、外部公開
    │  Gate 5: BEユニットテスト通過、デプロイ成功
    ▼
  運用フェーズへ
```

**重要**: Step 5 のデプロイは Step 3 中盤（機能の40〜60%完成時点）から**並行して**開始する。フロー図の順序は品質ゲートの論理的な依存関係を示すが、デプロイは早期フィードバックのために前倒しする。

### 1.4 DD（Design Decision）単位での進行

本マニュアルでは、各実装作業を**DD（Design Decision）**単位で管理することを推奨する。DDは以下の特性を持つ:

- **1DDの粒度**: 1つの設計判断 + その実装。通常は1画面 or 1機能に対応
- **フェーズ構成**: Phase 0（事前精査） → Phase 1〜N（実装） → DA（批判レビュー）
- **アーカイブ**: 完了したDDはアーカイブされ、仕様書・テストが永続資産として残る

---

## 2. Step 1: 垂直スライス

> **目的**: 全レイヤー（DB → Backend → Frontend）の技術的疎通を、最小限の機能で検証する
>
> **仕様書作成マニュアル Step 3 との関係**: 仕様書作成マニュアル Step 3 で実施した設計検証PoC（垂直スライス）を、本実装コードベースとして発展させる。同一コードベースであればそのまま継続し、本ステップの追加要件（エラーハンドリング雛形・UI設計ガイドライン・テスト雛形等）を満たすまで拡張する。

### 2.1 対象機能の選定

垂直スライスの対象は、**アーキテクチャ検証に最適な機能**を選ぶ。最も複雑な機能ではない。

| 選定基準 | 推奨 | 非推奨 |
|---------|------|--------|
| 全レイヤーを通せる | ✅ CRUD + 認証 | ❌ バッチ処理（FEなし） |
| 依存関係が少ない | ✅ マスタデータ管理 | ❌ 他テーブルに大量FK依存 |
| 業務ロジックが軽い | ✅ 参照・更新のみ | ❌ 複雑な計算・集計 |

> **例**: 最初の垂直スライスの目的はアーキテクチャ検証であり業務ロジック検証ではない。業務ロジックは VERIFIED 仕様書で担保済みで、残るリスクは「技術スタックが実際に動くか」。ある実プロジェクトでは、当初「最も複雑なモジュール」を PoC 対象としていたが、「認証 + マスタCRUD」に変更し、技術的課題（FK依存・Cookie疎通等）を早期に解決できた。

### 2.2 手順

#### 2.2.1 DB層

1. **全マスタテーブルの一括マイグレーション**: FK依存がある場合、対象テーブルだけでなく参照先も含めて作成する
2. **シードデータの投入**: 開発用の最小限データ（3〜5レコード）
3. **マイグレーションツールの検証**: Alembic / Prisma / Flyway 等が正常に動作することを確認

> **落とし穴**: 最小限のテーブルだけではFK制約の芋づる式依存を検出できない。マスタテーブルは全量を初回マイグレーションに含めるべき。あるプロジェクトでは初回マイグレーションを14テーブルに拡大したことで、後続の実装でFK関連の問題が一切発生しなかった。

#### 2.2.2 Backend層

1. **N層構成の検証**: Model → Repository → Service → Router 等の各層を実装
2. **認証フローの完成**: ログイン → トークン発行 → 保護エンドポイント → トークン更新
3. **エラーハンドリングの雛形**: 422（バリデーション）、401（認証）、403（認可）、409（競合）
4. **テストの雛形**: 各層のテストパターンを確立

**アーキテクチャパターン（推奨）**:

```
Router（入口）
  ├── L1バリデーション（型・形式チェック）
  ├── 認証チェック（JWT検証、CurrentUser注入）
  └── Service 呼び出し
        ├── L2バリデーション（業務ルールチェック）
        ├── 権限チェック
        └── Repository 呼び出し
              └── DBクエリ
```

> **効果**: 垂直スライスで確立した N 層構成パターンと BaseRepository ジェネリックパターンが全エンティティで再利用され、CRUD実装の工数を大幅に削減する。

#### 2.2.3 Frontend層

1. **ルーティング・認証ガードの検証**: ログイン画面 → 認証 → 保護ページ
2. **API呼び出しパターンの確立**: データフェッチ + キャッシュ戦略
3. **UIコンポーネントライブラリの検証**: テーブル表示、フォーム入力、モーダル等の基本パターン
4. **開発環境の検証**: HMR、プロキシ設定、Cookie疎通

#### 2.2.4 UI設計システムの確立

垂直スライスと同時期に、UIの設計方針を確定する:

1. **表示密度の決定**: 業務アプリでは「1画面に何行表示できるか」が生産性に直結する
2. **テーブルライブラリの PoC**: インライン編集・ソート・フィルタが要件に合うか検証
3. **デザインガイドラインの文書化**: フォントサイズ、パディング、カラーパレット等
4. **CLAUDE.md からの参照設定**: ガイドライン文書をプロジェクトの AI 設定ファイルから参照させる

> **例**: あるプロジェクトでは、UIライブラリのデフォルト設定（5行/画面）が業務アプリとして使えないことがPoC で判明。全コンポーネントの密度を調整し、1080p で31行表示を実現した。この判断がStep 1 で行われたため、全画面で最初から適切な密度で実装できた。

#### 2.2.5 デザインガイドラインと LLM 連携

LLM（Claude Code 等）を使って開発する場合、**UI設計ガイドラインを文書化し、プロジェクトの CLAUDE.md から参照させる**ことが極めて重要。LLM は CLAUDE.md の指示に暗黙的に従うため、ガイドラインを定義しておけば明示的に指示しなくても全画面で一貫したデザインが適用される。

**ガイドラインの推奨構成**:

| セクション | 定義すべき内容 |
|-----------|--------------|
| レイアウト | フォントサイズ、行高、パディング、1画面あたりの表示行数目標、最小対応幅 |
| カラー | プライマリ/セカンダリ/エラー/警告色、コントラスト基準 |
| コンポーネント | ボタンサイズ、フォーム幅、モーダルサイズ、テーブル列幅、アイコン使用方針 |
| 編集可能テーブル | 2モード制（ナビゲーション/編集）の挙動定義、コミットパターン、キーボード操作 |
| インタラクション | ローディング表示、成功/失敗通知、確認ダイアログの出し方 |

**CLAUDE.md への記載方法**:

```markdown
## 仕様書ルール（必ず守ること）
- `doc/spec/ui-design-guideline.md` — 画面の新規作成・デザイン変更時は必ず読み込むこと
```

この1行で、LLM が画面を新規作成するたびにガイドラインを参照し、一貫したデザインで実装する。ガイドラインを更新すれば、以降の全画面が自動的に新しい方針に従う。

#### 2.2.6 編集可能テーブル（Excel ライク入力表）の PoC

業務アプリでは**Excelライクな入力表**がほぼ必ず必要になる。明らかに不要な場合を除き、垂直スライスの段階で PoC を実施し、パターンを確立する。

**検証すべき項目**:

| 項目 | 内容 |
|------|------|
| テーブルライブラリ選定 | インライン編集・ソート・フィルタ・仮想スクロール対応 |
| 2モード制 | デフォルトはナビゲーションモード（テキスト表示）。F2/ダブルクリック/文字入力で編集モードに遷移 |
| コミットパターン | onBlur でコミット + committedRef パターンで再レンダリング制御。Escape でキャンセル |
| キーボード操作 | Tab/Enter で次セル移動、矢印キーでセル間移動、Ctrl+S で保存 |
| バリデーション | セル単位の即時バリデーション + 行単位のクロスバリデーション |

> **なぜ垂直スライスで PoC するか**: 編集可能テーブルのパターンは核機能（Step 2）以降の全入力画面の規範になる。Step 2 で初めて取り組むと、テーブルライブラリの制約に引きずられて設計が歪む。垂直スライスでパターンを確立しておけば、核機能では業務ロジックに集中できる。

### 2.3 Gate 1: 垂直スライス疎通

| チェック項目 | 必須 |
|-------------|------|
| DB マイグレーションが正常に動作し、FK依存を含む主要テーブルが作成されている | ✅ |
| Backend の N 層構成が動作している | ✅ |
| 認証フロー（ログイン → トークン → 保護EP → トークン更新）が動作している | ✅ |
| Frontend からBackend APIを呼び出し、データの取得・更新ができている | ✅ |
| エラーハンドリングの雛形（422/401/403/409）が動作している | ✅ |
| テストの雛形が各層に存在し、全てパスしている | ✅ |
| UI設計ガイドラインが文書化され、CLAUDE.md から参照されている | ✅ |
| 編集可能テーブルの PoC が完了している（不要な場合はスキップ理由を記録） | ✅ |
| ログ基盤（構造化ログ + request_id）が構築されている | ⚠️ 強く推奨 |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

> **ログ基盤について**: Gate 1 の必須項目ではないが、**強く推奨**する。ログ基盤の遅延は1〜2日分のデバッグ工数増に直結する（AP-1 参照）。遅くとも Step 4（品質ゲート）までに構築すること。

### 2.4 よくある落とし穴

- **最小限すぎるマイグレーション**: 対象テーブル1つだけでは FK 制約の芋づる式依存を検出できない。マスタテーブルは全量を初回マイグレーションに含めるべき
- **PoC対象に最も複雑な機能を選ぶ**: 垂直スライスの目的はアーキテクチャ検証。業務ロジックの検証は VERIFIED 仕様書が担保する
- **UI設計を後回しにする**: 業務アプリの表示密度は後から変更すると全画面に影響する。テーブルの行数・フォントサイズ・パディングは垂直スライス段階で確定させる
- **Async/Sync等のインフラ決定を先送りする**: DBアクセスの同期/非同期方式等は全 Repository に影響する。垂直スライスで確定すべき
- **デザインガイドラインを文書化しない**: LLM は CLAUDE.md から参照されたガイドラインに暗黙的に従う。文書化しなければ画面ごとにバラバラなデザインが生まれる
- **編集可能テーブルの PoC を後回しにする**: テーブルライブラリの制約は全入力画面に影響する。核機能で初めて触ると、ライブラリの制約に引きずられて設計が歪む

---

## 3. Step 2: 核機能の実装

> **目的**: 最も複雑な機能を3分割パターンで構築し、実装の雛形を確立する

### 3.1 なぜ「最も複雑な機能」から攻めるか

垂直スライス（Step 1）で技術疎通が確認できたら、次は**最も複雑な機能**を実装する。理由:

1. **最大のリスクを早期に解消**: 複雑な機能ほど仕様とアーキテクチャの不整合が顕在化しやすい
2. **実装パターンの確立**: 最も複雑な機能で確立したパターンは、残りの機能にそのまま適用できる
3. **速度の加速**: 核機能の実装パターンが確立すると、放射的実装（Step 3）が飛躍的に高速化する

> **例**: あるプロジェクトでは、最も複雑な入力画面（4タブ・12バリデーション条件・インライン編集・承認フロー）を最初に実装。この画面で確立したカスタムフック・バリデーションパターン・N層 Backend パターンが、後続の15画面でそのまま再利用された。

### 3.2 3分割パターン

複雑な機能は、一度に完成させるのではなく、3つのDDに分割して段階的に品質を積み上げる:

| Phase | 焦点 | ゴール | Gate |
|-------|------|--------|------|
| **Phase 1: 動作** | 機能が動くこと | 全レイヤーでデータが流れる | CRUD が正常動作 |
| **Phase 2: 見た目** | UIが使えること | レイアウト・操作性の最適化 | HTMLモック比較でUI合格 |
| **Phase 3: 正確性** | ロジックが正しいこと | バリデーション・ビジネスルール完成 | 全条件のテスト通過 |

**なぜ3分割か**: 「一度に全部正しく作る」は、以下の理由で失敗する:

- Phase 1 で動かしてみると、設計段階で想定していなかった技術的制約が判明する
- Phase 2 で実際のUIを触ると、レイアウトの再設計が発生する
- Phase 3 でロジックを厳密化すると、Phase 1-2 の前提が変わることがある

> **例**: あるプロジェクトでは、Phase 1 で旧システム踏襲の4タブ構成で実装。Phase 2 で新フレームワークの能力を活かして1統合画面に全面再設計した。これは Phase 1 で動くものを触ったからこそ生まれた判断。Phase 3 で旧システムから12バリデーション条件を全量移植し、テスト69件を実装。同じ3分割パターンを別の機能群（売上入力: BE → FE → 横断機能）にも適用し、成功を再現した。

### 3.3 Phase 0: 事前精査（各DDで必須）

**各DDの実装に入る前に、Phase 0 で以下を必ず実施する**:

> **なぜ VERIFIED 仕様書を再検証するか**: `[VERIFIED]` は「現時点で根拠をもって合意された仕様」であり、完全無欠を意味しない。特にUI層のバリデーション条件はサービス層中心の仕様書から漏れやすい。Phase 0 は実装直前の最終防衛線として機能する。

| チェック項目 | 方法 | 目的 |
|-------------|------|------|
| **移行元 submit/save 関数の全量精査** | 移行元コードのバリデーション条件を全てリストアップ | UIとビジネスルールの完全な把握 |
| **仕様書との差分確認** | リストアップした条件と VERIFIED 仕様書を突合 | 仕様漏れの早期発見 |
| **状態遷移の確認** | 対象機能にステータスがある場合、状態遷移図を作成 | ワークフロー破壊の防止 |
| **データアクセスパターンの確認** | 対象テーブルの参照パターンを既存実装と比較 | アクセス不整合の防止 |
| **仕様→テスト対応表の作成** | 仕様書の各 BR-ID（ビジネスルールID）に対応するテストケースIDを記録 | 仕様カバレッジの可視化 |
| **DA批判レビュー** | 最低1件の構造的問題を発見する | 見落としの発見 |

> **例**: あるプロジェクトでは Phase 0 で移行元の UI 層バグ4件を事前発見。別の画面でも仕様書のバグ4件を Phase 0 で発見。Phase 0 を省略していたら、これらは実装後のデバッグで発覚し、数倍のコストがかかっていた。

### 3.4 設計判断の記録

核機能の実装では、以下のような設計判断が頻出する。これらは後続DDの規範になるため、**必ず文書化する**:

| 判断カテゴリ | 例 | 影響範囲 |
|-------------|---|---------|
| データモデリング | BOOLEAN vs ENUM の選択 | 全画面の参照パターン |
| 計算ロジックの配置 | FE/BE二重実装、BEがSSOT | 全計算画面 |
| 権限チェックパターン | ユーティリティ関数への集約 | 全エンドポイント |
| 競合制御 | 楽観ロック + version カラム + 409レスポンス | 全更新画面 |
| ルート順序 | 固定パスを変数パスより前に配置 | 全ルーター |

### 3.5 Gate 2: 核機能完成・画面間不整合レビュー

| チェック項目 | 必須 |
|-------------|------|
| 核機能（最も複雑な画面）の3分割パターンが全て完了している | ✅ |
| 全バリデーション条件が移行元から移植され、テストが存在する | ✅ |
| 設計判断（データモデル・計算配置・権限パターン等）が文書化されている | ✅ |
| 核機能と関連画面（存在する場合）の間で不整合がないことを確認している | ✅ |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

### 3.6 よくある落とし穴

- **一度に全部作ろうとする**: Phase 1 で動かしてみないとわからない技術的制約がある。動くものを触ることで、設計の再考が生まれる
- **Phase 0 の submit/save 精査を省略する**: UI層のバリデーション条件はサービス層の仕様書に含まれていないことが多い。Phase 0 で全量リストアップしないと、Phase 3（正確性）で大量の追加作業が発生する
- **設計判断を暗黙のままにする**: 核機能で決めた設計パターンが後続DDで「なんとなく踏襲」されると、微妙な不整合が蓄積する。明示的に文書化して参照可能にする

---

## 4. Step 3: 放射的実装

> **目的**: 核機能で確立したパターンを使い、依存画面群を効率的に展開する

### 4.1 放射的実装の原理

核機能（Step 2）で確立したパターン・コンポーネント・ユーティリティを再利用し、依存画面を高速に展開する:

```
           ┌── 承認画面         ← バリデーション関数を再利用
           ├── 月次レポート     ← 集計SQLパターンを再利用
核機能 ────┼── アラート画面     ← チェックモデルを再利用
           ├── 残高管理         ← 計算ユーティリティを再利用
           └── HR管理           ← 権限チェックパターンを再利用
```

**速度の複利効果**: 核機能で確立した1パターンが N 画面で再利用される。実プロジェクトでは、Day 2-3 で実装速度が飛躍的に向上し、核機能の実装パターンが放射的に再利用される「複利効果」が観測された。

### 4.2 手順

#### 4.2.1 依存グラフの作成

核機能と依存画面の関係を明示的にマッピングする:

1. 核機能が生成するデータを消費する画面のリスト
2. 核機能で確立したコンポーネント・フック・ユーティリティの再利用可能性
3. 各画面固有の追加要件（新規テーブル・独自ロジック等）

#### 4.2.2 StubPage 方式

放射的実装では、まず全画面を**スタブ**として作成し、段階的に中身を実装する:

1. **全画面のルーティング・ナビゲーション登録**: 空の画面でもルーティングに登録しておく
2. **優先度順に実装**: 核機能との依存度が高い画面から順に実装
3. **各画面は1DDで完結**: 1DD = 1画面が基本粒度

#### 4.2.3 横断バグの即時修正

放射的実装中に発見された横断的なバグは、**次のDDを待たずに即時修正する**:

> **例**: ある派生画面の DA で権限チェックバグを発見。通常なら Phase 末レビューまで待つところだが、パターン化された修正（5画面の条件修正）は即時対応した。「既知パターンの機械的修正」と「未知の探索的発見」を分離することで、並行作業が可能になった。

#### 4.2.4 コンポーネント反映サイクル

放射的実装では、派生画面で**核機能にはなかった汎用的なパターンやコンポーネント**が生まれることがある。これらはバグではないが、全画面に反映すべきかを判断し、ガイドラインを成長させる。

**反映サイクル**:

```
派生画面で新パターンを発見・実装
    │
    ▼
「他の画面にも適用すべきか？」を判断
    │
    ├── Yes → UI設計ガイドラインに追記
    │         既存画面への遡及適用（1DDで実施）
    │         CLAUDE.md の参照指示を更新
    │
    └── No  → その画面固有の実装として保持
```

**反映すべきパターンの例**:

| 発見元 | パターン | 反映先 |
|--------|---------|--------|
| レポート画面 | フィルター機能の汎用実装 | 全テーブル画面 |
| 設定画面 | 新しいバリデーションUXパターン | 全フォーム |
| 承認画面 | ローディング表示の改善 | 全API呼び出し画面 |
| 管理画面 | キーボードショートカット | 全編集画面 |

**なぜ重要か**: ガイドラインは静的な文書ではなく、**実装を通じて成長する生きたドキュメント**。派生画面で得た知見をガイドラインにフィードバックすれば、LLM が以降の画面を最初から改善されたパターンで生成する。ガイドラインを更新しなければ、LLM は古いパターンを使い続け、後で全画面の改修が必要になる。

### 4.3 テスト戦略

放射的実装でのテスト方針:

| テスト種別 | タイミング | 目安 |
|-----------|----------|------|
| **BE ユニットテスト** | 各DD完了時 | エンドポイントあたり3〜5件 |
| **FE コンポーネントテスト** | 各DD完了時 | 画面あたり3〜5件 |
| **統合テスト** | Step 3 完了時（Gate 3 で一括） | 主要フローあたり1〜2件 |
| **E2E テスト** | Step 5（UIが安定してから） | ユーザーストーリーあたり1件 |

> **注意**: UIが頻繁に変更される期間にE2Eテストを書いても壊れるだけ。ある実プロジェクトではUIが5回変更されたため、早期E2Eは無駄になっていた。

### 4.4 横断DA分析

放射的実装で**3DD以上のシリーズ**が完了したら、個別DDのDAとは別に**横断DA分析**を実施する:

| 分析観点 | チェック内容 |
|---------|------------|
| **権限一貫性** | 全エンドポイントで統一パターンが適用されているか |
| **データフロー整合性** | 画面間でデータの参照タイミング（月初/月末等）が統一されているか |
| **エラーハンドリング統一** | 401/403/409/422 の処理が全画面で一貫しているか |
| **UI一貫性** | テーブルの行数・フォントサイズ・操作性が画面間で統一されているか |

> **教訓**: 3DD完了後に横断DAを先送りした結果、5ラウンドのDA分析が必要になった事例がある。3DD完了時点で横断DAを実施していれば、後のラウンドで発見された状態遷移バグを事前に検出できていた。

### 4.5 Gate 3: 放射的実装完了

| チェック項目 | 必須 |
|-------------|------|
| 全依存画面の実装が完了している | ✅ |
| 各画面の BE ユニットテスト・FE コンポーネントテストが存在する | ✅ |
| 横断DA分析（権限・データフロー・エラーハンドリング・UI一貫性）を実施している | ✅ |
| 横断DAで発見された問題が全件修正されている | ✅ |
| 派生画面で発見した汎用パターンをガイドラインに反映している | ✅ |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

### 4.6 よくある落とし穴

- **横断DAの先送り**: 3DD以上のシリーズ完了後に横断DAを実施しないと、状態遷移バグ・権限の不整合が蓄積する
- **権限チェックの個別実装**: 各画面で独自に権限条件を書くと、条件分岐の微妙な差異が権限バイパスを生む。統一ユーティリティに集約する
- **E2Eテストの早期実施**: UI が安定する前に E2E テストを書くと、画面変更のたびにテストが壊れる。E2E は Step 5（UI安定後）まで待つべき
- **ガイドラインを更新しない**: 派生画面で良いパターンを見つけても、ガイドラインに反映しなければ LLM は古いパターンを使い続ける。後で全画面を改修する羽目になる

---

## 5. Step 4: 品質ゲート

> **目的**: システム全体を横断的に監査し、個別DD・個別画面のDAでは発見できない構造的問題を解消する

### 5.1 なぜ Step 4 が独立ステップか

個別DDのDA批判レビューには**構造的な盲点**がある:

| 盲点 | 原因 |
|------|------|
| 画面間のデータ不整合 | DAは1DD単位で実施。他画面のロジックを見ない |
| ワークフロー状態遷移の破壊 | 仕様書が計算ロジックに集中し、状態遷移が曖昧 |
| ログ・監査証跡の完全欠如 | 各DDでは「機能が動くこと」に集中 |
| 権限チェックパターンの不統一 | 早期DDで確立したパターンが後期DDで変異 |

> **例**: ある実プロジェクトでは、3回の横断レビュー（勤怠系完了後・売上系完了後・全体）で合計30件のHIGH以上の問題が発見された。これらは全て個別DDのDAでは検出不可能だった。

### 5.2 多角的コード監査（5つの視点）

以下の5つの視点でシステム全体を監査する:

#### 5.2.1 SSOT（Single Source of Truth）

| チェック項目 | 方法 |
|-------------|------|
| 同一データが複数箇所で定義されていないか | enum/定数の定義箇所を全量検索 |
| FE/BE で同じ定数のラベルが一致しているか | 表示ラベルの突合 |
| 計算ロジックが FE/BE で二重実装されている場合、SSOT はどちらか明確か | レスポンス生成時の再計算有無を確認 |

#### 5.2.2 DRY（Don't Repeat Yourself）

| チェック項目 | 方法 |
|-------------|------|
| コピー&ペーストされたコードブロックはないか | 類似コードの検索（4行以上の重複） |
| ユーティリティに集約すべきパターンはないか | 3箇所以上で使われるパターンの抽出 |
| テスト用のヘルパーが共通化されているか | テストファイル間の fixture 重複確認 |

#### 5.2.3 権限・セキュリティ

| チェック項目 | 方法 |
|-------------|------|
| 全エンドポイントに認証チェックが存在するか | Router 層のデコレータ有無を全量確認 |
| 権限チェックが統一パターンで実装されているか | ユーティリティ関数の利用有無 |
| ユーザー入力の Excel Formula Injection 対策が施されているか | CSV/Excel出力箇所の確認 |
| テナント制約（branch_id 等）が全 mutation で適用されているか | UPDATE/DELETE クエリの WHERE 句確認 |

#### 5.2.4 並行操作・データ整合性

| チェック項目 | 方法 |
|-------------|------|
| 楽観ロック（version カラム）が全更新画面で実装されているか | UPDATE クエリの version チェック有無 |
| 409 Conflict レスポンスが FE で適切にハンドリングされているか | FE の error handling 確認 |
| 承認後のデータが上書き防止されているか | 承認済みレコードの UPDATE 条件確認 |

#### 5.2.5 エラーハンドリング・ログ

| チェック項目 | 方法 |
|-------------|------|
| 全エンドポイントに構造化ログが存在するか | logging 呼び出しの全量確認 |
| Request Context（request_id, user_id）がログに含まれるか | ログフォーマットの確認 |
| FE の Error Boundary が設置されているか | エラー表示の確認 |
| エラー時にユーザーに適切なメッセージが表示されるか | 各ステータスコードの表示確認 |

### 5.3 ログ基盤の構築

品質ゲートの段階でログ基盤が存在しない場合、**即座に構築する**:

**ログ基盤の推奨構成**:

| Phase | 内容 |
|-------|------|
| Phase 1 | RequestContextMiddleware + request_id + user context（構造化ログ） |
| Phase 2 | FE Error Boundary + client-error 送信エンドポイント |
| Phase 3 | リクエストボディログ（サイズ制限 + パスワードマスク） |

> **教訓**: ログなしでの運用は「目をつぶって運転する」に等しい。理想は Step 1 直後に構築。遅くとも Step 4 で構築する。

### 5.4 Gate 4: 品質ゲート通過

| チェック項目 | 必須 |
|-------------|------|
| 5つの視点（SSOT/DRY/権限/並行操作/ログ）での横断監査が完了している | ✅ |
| HIGH 以上の issues が 0 件になっている | ✅ |
| ログ基盤が稼働し、全エンドポイントで構造化ログが出力されている | ✅ |
| FE Error Boundary が設置されている | ✅ |
| 権限チェックが統一パターンで集約されている | ✅ |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

### 5.5 よくある落とし穴

- **ログ基盤を最後に回す**: 本番障害の調査にログは不可欠。理想は Step 1 直後、遅くとも Step 4 で構築する
- **品質ゲートを最後に1回だけ実施する**: 機能群ごとに品質ゲートを入れることで、問題の蓄積を防止できる
- **「個別DDのDAで十分」と判断する**: 個別DDのDAは1画面単位のため、画面間の不整合・ワークフロー破壊・ログ欠如等の構造的問題は検出できない

---

## 6. Step 5: 拡張・テスト・デプロイ

> **目的**: UI改善、テスト基盤強化、本番デプロイを通じてシステムを外部公開可能にする

### 6.1 デプロイのタイミング

**核機能の40〜60%が完成した段階で、本番環境へのデプロイを開始する**。全機能完成を待たない。

理由:
1. **ステークホルダーからの早期フィードバック**: 実際に触ってもらうことで、仕様書では見えなかった要件が判明する
2. **インフラの問題発見**: ローカルでは再現しないパフォーマンス・メモリ・ネットワーク問題が本番で顕在化する
3. **デプロイ自体の検証**: nginx設定・Docker構成・SSL・パスプレフィックス等、デプロイ固有の技術課題を早期に解決できる

> **例**: あるプロジェクトでは50%完成時点でデプロイ。ステージング環境（低スペック）が OOM で失敗し、翌日に本番環境（高スペック）に切り替えて成功。**1回のピボットを想定してインフラを準備しておくべき**。

### 6.1.1 デプロイ起因の仕様変更管理

デプロイ後のフィードバックで VERIFIED 仕様書の変更が必要になった場合、以下のルールに従う:

| 変更規模 | 対応 | 承認 |
|----------|------|------|
| **軽微**（表示ラベル変更、UIレイアウト微調整） | 実装 DD 内で対応し、仕様書を同時更新 | DD 内 DA で承認 |
| **中規模**（バリデーション条件の追加・変更、ワークフロー分岐の追加） | 専用 DD を起票し、Phase 0 で仕様書を先に更新してから実装 | DA 必須 |
| **大規模**（画面統合・分割、データモデル変更） | 仕様書作成マニュアル Step 2-3 に差し戻し | 関係者合意 |

> **原則**: 仕様書は実装の結果ではなく、実装の根拠であり続ける。「実装してから仕様書を追従更新」ではなく、「仕様書を更新してから実装を変更」の順序を守る。

### 6.2 デプロイ前チェックリスト

| チェック項目 | 詳細 |
|-------------|------|
| **メモリ見積もり** | Docker ビルド時のピークメモリを事前に計測。Swap 2GB 以上を確保 |
| **ログドライバ** | Docker ログの max-size / max-file を設定 |
| **パスプレフィックス** | FE / BE の両方でパスプレフィックス対応（既存サービスとの共存用） |
| **SEED_MODE** | 初回は full seed、2回目以降は migrate のみ（restart での重複実行防止） |
| **ヘルスチェック** | `/health` EP の実装（Docker HEALTHCHECK + 外部監視） |
| **SSL/TLS** | 証明書の設定と自動更新 |

> **注意**: ビルド時のメモリピーク ≠ 実行時のメモリ使用量。ビルド時は3〜4倍必要。

### 6.3 UI改善（UXリファインメント）

デプロイ後のフィードバックに基づき、UIを改善する:

| 改善カテゴリ | 例 |
|-------------|---|
| **操作性** | キーボードナビゲーション、Tab順序、ショートカットキー |
| **視認性** | カラーコントラスト、フォントサイズ、セル幅の自動調整 |
| **効率性** | インライン編集の2モード制（ナビゲーション/編集）、一括操作 |
| **フィードバック** | 保存成功/失敗の通知、ローディング状態、楽観的UI更新 |

### 6.4 テスト戦略

| フェーズ | テスト種別 | タイミング | 目安 |
|---------|----------|----------|------|
| Step 2-3 | **BE ユニットテスト** | 各DD完了時 | 純粋関数のテスト。エンドポイントあたり3-5件 |
| Step 3 完了後 | **統合テスト** | 横断DA時 | ワークフロー1本あたり1-2件 |
| Step 5 | **E2E テスト** | UI安定後 | ユーザーストーリーあたり1件 |
| 最終Phase | **TDD（新規計算）** | 新しい複雑な計算 | 計算ルールの事前テスト作成 |

**テストを書かない方がよいタイミング**:

- UIが頻繁に変更される期間に E2E テストを書いても壊れるだけ
- 新規計算ロジックの設計が固まっていない段階での TDD は手戻りが発生する

### 6.5 Gate 5: 拡張・テスト・デプロイ完了

| チェック項目 | 必須 |
|-------------|------|
| 本番環境へのデプロイが成功し、ヘルスチェックが通過している | ✅ |
| BE ユニットテストが全件パスしている | ✅ |
| ステークホルダーからのフィードバックが収集されている | ✅ |
| UIの主要な改善が反映されている | ✅ |
| ログ基盤が本番環境で稼働し、エラーが可視化されている | ✅ |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

### 6.6 よくある落とし穴

- **全機能完成を待ってからデプロイ**: 40〜60% で出すことで、残りの実装方針にフィードバックを反映できる
- **ステージング環境を過信する**: ステージングと本番のスペック差が問題を隠す。1回のピボットを想定しておく
- **E2Eテストを早期に書く**: UI が安定するまで E2E テストは書かない

---

## 7. DA批判レビュー運用ガイド

### 7.1 DAの義務化

**全DDの全Phaseで、DA批判レビューを義務化する**。DAの目的は「何が壊れるか」を最低1件発見すること。問題未発見の場合は、検証した観点・手順・ログを記録することでゲート通過を認める。

### 7.2 DAの視点ローテーション

同じ視点からのレビューでは発見率が低下する。Phase ごとに視点を変える:

| Phase | 視点 | 問う質問 |
|-------|------|---------|
| Phase 0（事前精査） | **設計者** | 「この設計で見落としている依存関係は？」 |
| Phase 1-2（実装） | **実装者** | 「エッジケース・権限バイパス・並行操作で壊れないか？」 |
| 最終Phase（完了） | **保守者** | 「半年後に別の人がこのコードを変更する時、何が壊れるか？」 |
| 横断レビュー | **新メンバー** | 「初めてこのシステムを見た人が混乱する箇所はどこか？」 |

### 7.3 高発見率の DA チェック項目

過去の実績から、特に発見率が高い DA チェック項目:

| 観点 | 質問例 | 発見率 |
|------|--------|--------|
| **権限バイパス** | 「テナント制約が全 mutation で適用されているか？」 | 高（80%） |
| **エラーパス** | 「外部API/DBエラー時にユーザーに何が表示されるか？」 | 高（85%） |
| **仕様の曖昧さ** | 「ステータスフィールドの状態遷移ルールは明確か？」 | 中（60%） |
| **境界条件** | 「月末・月初・中途入退社者で計算結果はどうなるか？」 | 中（50%） |
| **データ不整合** | 「関連画面が同じテーブルを同じ日付基準で参照しているか？」 | 低（30%） → 横断DAで高 |

### 7.4 多ラウンドDAパターン

複雑な機能（3DD以上のシリーズ）では、1回のDAでは不十分。ラウンドを重ねる:

| Round | 手法 | 発見の性質 |
|-------|------|----------|
| Round 1 | 横断型（BE/FE/仕様突合） | コンポーネントレベルのバグ |
| Round 2 | 全行精読 | 実装の不整合 |
| Round 3 | 動線トレース図 | ワークフローレベルのバグ |
| Round 4 | ビジネスプロセス検証 | 仕様の曖昧さに起因する問題 |
| Round 5 | リグレッション | 修正が生んだ新しい問題 |

> **教訓**: 5ラウンド必要になるケースは、仕様書の状態遷移記述が不足していたことが根本原因。仕様の品質が高ければ Round 1-2 で十分。

### 7.5 DAの品質確保

「DA を実施した」だけでは形骸化する。以下を守る:

- **重要度 MEDIUM 以上**の指摘を最低1件含むこと（LOW のみは形骸化の兆候）
- **再現手順**を必ず記載すること（HIGH/MEDIUM は必須）
- **対応方針**を明記し、修正完了まで追跡すること
- 発見した問題はログに記録し、パターンとして蓄積すること

---

## 8. アンチパターン集

実プロジェクトの実装経験から発見された「やってはいけない」こと:

### AP-1: ログ基盤なしで実装を進める

**症状**: 機能は動作するが、本番でエラーが発生しても原因を特定できない
**対策**: Step 1（垂直スライス）完了直後にログ基盤を構築する。最低限 RequestContextMiddleware + request_id + 構造化ログ

### AP-2: 権限チェックを各画面で個別実装する

**症状**: 画面ごとに権限チェックの条件分岐が微妙に異なり、特定の権限組み合わせでバイパスが発生する
**対策**: Step 2（核機能）で権限チェックのユーティリティを確立し、全画面で統一パターンを使用する

### AP-3: 3DD以上のシリーズで横断DA分析を省略する

**症状**: 個別DDのDAは通過するが、画面間のワークフロー破壊や状態遷移の不整合が蓄積する
**対策**: Step 3（放射的実装）の Gate 3 で横断DA分析を義務化

### AP-4: 品質ゲートを最後に1回だけにする

**症状**: 問題が蓄積し、最後の品質ゲートで大量の修正が必要になる
**対策**: 機能群ごとに品質ゲートを入れる（Step 3 の Gate 3 + Step 4 の Gate 4）

### AP-5: UI設計を後回しにする

**症状**: 機能は完成するが、UIの表示密度・操作性が業務要件を満たさず、全画面の改修が必要になる
**対策**: Step 1（垂直スライス）でUI設計方針を確定する

### AP-6: 全機能完成を待ってからデプロイする

**症状**: デプロイ固有の問題（メモリ・ネットワーク・パスプレフィックス等）が最後に発覚し、リリース遅延が発生する
**対策**: Step 5 のデプロイは40〜60%完成時点で開始する

### AP-7: 「修正完了」の自己宣言で品質ゲートを閉じる

**症状**: 修正した箇所は正しいが、修正が生んだ副作用で新たなバグが発生する
**対策**: 修正後は必ずリグレッションチェック（影響範囲のDA再実施）を行う

### AP-8: E2Eテストを UI 安定前に書く

**症状**: UI変更のたびにE2Eテストが壊れ、テストの保守コストが実装コストを上回る
**対策**: E2E テストは Step 5（UI安定後）まで待つ。Step 2-3 では BE ユニットテストと FE コンポーネントテストに集中する

---

## 9. 統合チェックリスト

全ゲートの統合チェックリスト。**各ステップの完了時に対応するゲートのチェックを実施する**。

### Step 1: 垂直スライス

- [ ] DB マイグレーションが正常に動作し、FK依存を含む主要テーブルが作成されている
- [ ] Backend の N 層構成が動作している
- [ ] 認証フロー（ログイン → トークン → 保護EP → トークン更新）が動作している
- [ ] Frontend からBackend APIを呼び出し、データの取得・更新ができている
- [ ] エラーハンドリングの雛形（422/401/403/409）が動作している
- [ ] テストの雛形が各層に存在し、全てパスしている
- [ ] UI設計ガイドラインが文書化され、CLAUDE.md から参照されている
- [ ] 編集可能テーブルの PoC が完了している（不要な場合はスキップ理由を記録）
- [ ] ⚠️ ログ基盤（構造化ログ + request_id）が構築されている（強く推奨）
- [ ] DA批判レビューを実施し、少なくとも1件の問題を発見・対応している

### Step 2: 核機能の実装

- [ ] 核機能（最も複雑な画面）の3分割パターンが全て完了している
- [ ] Phase 0 で移行元 submit/save 関数のバリデーション全量精査を実施している
- [ ] 全バリデーション条件が移行元から移植され、テストが存在する
- [ ] 設計判断（データモデル・計算配置・権限パターン等）が文書化されている
- [ ] 核機能と関連画面の間で不整合がないことを確認している
- [ ] DA批判レビューを実施し、少なくとも1件の問題を発見・対応している

### Step 3: 放射的実装

- [ ] 全依存画面の実装が完了している
- [ ] 各画面の BE ユニットテスト・FE コンポーネントテストが存在する
- [ ] 横断DA分析（権限・データフロー・エラーハンドリング・UI一貫性）を実施している
- [ ] 横断DAで発見された問題が全件修正されている
- [ ] 派生画面で発見した汎用パターンをガイドラインに反映している
- [ ] DA批判レビューを実施し、少なくとも1件の問題を発見・対応している

### Step 4: 品質ゲート

- [ ] 5つの視点（SSOT/DRY/権限/並行操作/ログ）での横断監査が完了している
- [ ] HIGH 以上の issues が 0 件になっている
- [ ] ログ基盤が稼働し、全エンドポイントで構造化ログが出力されている
- [ ] FE Error Boundary が設置されている
- [ ] 権限チェックが統一パターンで集約されている
- [ ] DA批判レビューを実施し、少なくとも1件の問題を発見・対応している

### Step 5: 拡張・テスト・デプロイ

- [ ] 本番環境へのデプロイが成功し、ヘルスチェックが通過している
- [ ] BE ユニットテストが全件パスしている
- [ ] ステークホルダーからのフィードバックが収集されている
- [ ] UIの主要な改善が反映されている
- [ ] ログ基盤が本番環境で稼働し、エラーが可視化されている
- [ ] DA批判レビューを実施し、少なくとも1件の問題を発見・対応している

## 関連リソース

| リソース | 用途 |
|---------|------|
| [01_仕様書作成マニュアル.md](01_仕様書作成マニュアル.md) | 本マニュアルの前提となる仕様作成工程 |
| [GUIDE_SPEC.md](../GUIDE_SPEC.md) | 仕様抽出のクイックリファレンス |
| [references/lessons_learned.md](../references/lessons_learned.md) | 実プロジェクト経験から得た教訓 |

---

*リエンジニアリング実践マニュアル — 実装ガイド（汎用版）*
