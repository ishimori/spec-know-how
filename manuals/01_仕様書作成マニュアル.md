# 仕様書作成マニュアル — レガシーシステムからの仕様抽出ガイド

> **対象フェーズ**: 移行判断 → 仕様抽出 → 設計 → 横断検証（コードを書く前の全工程）
> **本書の位置づけ**: プロジェクト固有情報を排除した汎用版（分家）
> **完全版**: 本マニュアルは実プロジェクトの実践経験から抽出したものです。具体的なDD番号・数値データを含む完全版は、プロジェクト内の `doc/リエンジニアリング手法/03_実践マニュアル/01_仕様書作成マニュアル.md` を参照してください。

---

## 1. 概要

### 1.1 このマニュアルの目的

レガシーシステムをリエンジニアリング（作り直し）する際、**コードを書く前に必要な仕様書・設計書を高品質で作成する**ための手順書。

「Quality In, Quality Out」— インプット（仕様書・設計）の品質が後工程の速度と品質を決定する。仕様抽出・設計に十分な時間を投じることで、実装フェーズでの手戻りを最小化できる。

### 1.2 前提条件

- リエンジニアリング対象のレガシーシステムが稼働中であること
- ソースコードにアクセスできること
- データベーススキーマ（DDL）にアクセスできること
- 生成AIを開発の主力ツールとして使うこと（ハルシネーション対策が必須となる）

### 1.3 全体の流れ

本マニュアルは Step 0〜4 の5段階で構成される。各ステップには**ゲート（通過基準）**が定義されており、ゲートを通過しない限り次のステップに進んではならない。

```
Step 0: 移行判断          「作り直すべきか？」の判断
    │  Gate 0: 移行方針の確定
    ▼
Step 1: ドキュメント棚卸し  既存資産のカタログ化と信頼度評価
    │  Gate 1: 全ドキュメントに信頼度ラベル付与
    ▼
Step 2: 業務ロジック抽出    コードから仕様書を機械的に抽出
    │  Gate 2: 全仕様書が [VERIFIED]
    ▼
Step 3: 設計              DB・アーキテクチャ・垂直スライス
    │  Gate 3: 垂直スライスで全レイヤー疎通
    ▼
Step 4: 横断検証           3領域の横断チェック
    │  Gate 4: 横断検証チェックリスト全項目クリア
    ▼
  実装フェーズへ（→ 02_実装マニュアル.md）
```

---

## 2. Step 0: 移行判断

> **目的**: 「段階的移行」か「完全リエンジニアリング（作り直し）」かを判断し、品質保証戦略を確立する

### 2.1 判断基準

以下の条件が**3つ以上**当てはまる場合、完全リエンジニアリングを推奨する:

| # | 判断基準 |
|---|---------|
| 1 | UIフレームワークの制約がビジネス要件を妨げている |
| 2 | 既存コードに型安全性がなく、状態管理が脆弱 |
| 3 | アーキテクチャが分離されておらず、UI/ロジック/データが密結合 |
| 4 | コードベースの規模が流用コスト > 書き直しコストの閾値を超えている |
| 5 | 5年以上の長期運用が見込まれ、保守性が最重要 |

> **例**: あるプロジェクトでは、Streamlit の re-run モデルがインライン編集・複数モーダルを阻害し、5つの条件全てに該当したため完全リエンジニアリングを選択した。

### 2.2 品質保証戦略の確立

リエンジニアリングを選択した場合、以下の品質保証プロセスを**プロジェクト開始前に**文書化する:

#### 3段階QCプロセス

1. **Code to Spec** — 現行コードから仕様書を機械的に逆生成する
2. **Spec to Test Spec** — 仕様書からテスト仕様書（合格基準）を作成する
3. **Implement & Verify** — テスト仕様書に基づいて実装・検証する

#### ハルシネーション対策

生成AIを使う以上、ハルシネーション（幻覚）のリスクは常に存在する。以下の対策を**義務化**する:

| 対策 | 具体的な実施方法 |
|------|----------------|
| **機械的抽出** | AST解析・正規表現でコードから事実を抽出。AIの解釈を挟まない |
| **クロスベリフィケーション** | 複数のAIセッションで仕様を生成し、突合して不整合を発見 |
| **Devil's Advocate（DA批判レビュー）** | 各工程で「何が壊れるか」を最低1件発見する義務 |
| **信頼度ラベル** | 全ドキュメントに [VERIFIED] / [DRAFT] / [UNVERIFIED] を付与 |

### 2.3 Gate 0: 移行方針の確定

| チェック項目 | 必須 |
|-------------|------|
| 移行方針（段階的 or 完全リエンジニアリング）が文書化されている | ✅ |
| 品質保証戦略（3段階QC + ハルシネーション対策）が文書化されている | ✅ |
| DA批判レビューの義務化が合意されている | ✅ |
| 技術スタック（新システム側）の候補が決定している | ✅ |

### 2.4 よくある落とし穴

- **「一部だけ流用」の誘惑**: フレームワーク依存コード（セッション管理、キャッシュ、UIコールバック）を一緒に引きずるリスク
- **品質保証の後回し**: ハルシネーションが累積して手戻りが爆発する。**仕様書を先に確定してから実装する**のが鉄則

---

## 3. Step 1: ドキュメント棚卸し

> **目的**: 既存の仕様書・設計書を評価し、信頼度ラベル付きカタログとして整理する

### 3.1 手順

#### 3.1.1 既存ドキュメントの全量把握

移行元プロジェクトに存在するドキュメントを全てリストアップする:

- 画面仕様書、DB定義書、API設計書、セキュリティ設計書
- 業務フロー図、用語集、その他

#### 3.1.2 信頼度評価

各ドキュメントを以下の基準で評価し、信頼度ラベルを付与する:

| 信頼度 | ラベル | 判定基準 | 扱い |
|--------|--------|---------|------|
| 90%以上 | `[VERIFIED]` | DDLやソースコードとの機械的突合で一致確認済み | そのまま参照可。実装時に最終確認 |
| 70-89% | `[DRAFT]` | 概ね正確だが、一部に未検証・推測が混在 | 参考にはなるが、実装前に必ず検証 |
| 70%未満 | `[UNVERIFIED]` | 構造は把握できるが内容の正確性は保証なし | 目次・構造としてのみ利用 |

#### 3.1.3 DDLとの機械的突き合わせ（必須）

DB定義書は信頼度ラベルに関わらず、**必ずDDLとの機械的突き合わせを実施する**:

1. DDL からテーブル一覧・カラム一覧を抽出
2. ドキュメントの記載と1:1で突合
3. 不足テーブル・カラム・制約を全量追記
4. 型の不整合を記録
5. 突き合わせ完了後、ラベルを `[VERIFIED]` に昇格

> **例**: あるプロジェクトでは DDL 突き合わせで、ドキュメントから完全に欠落していた中核テーブル（30+カラム）を発見した。信頼度65%のドキュメントを鵜呑みにしていたら、新システムの設計に致命的な欠落が生じるところだった。

#### 3.1.4 取り込みの優先順位

全ドキュメントを一度に精査するのではなく、優先順位をつけて段階的に取り込む:

| 優先度 | 対象 | 理由 |
|--------|------|------|
| **高** | テーブル定義・画面一覧・業務概要 | 後続の設計判断の基盤 |
| **中** | セキュリティ設計・アーキテクチャ概要 | 新システム設計の参考 |
| **低** | 個別画面仕様書（大量） | 実装フェーズで必要時に参照 |

### 3.2 Gate 1: ドキュメント棚卸し完了

| チェック項目 | 必須 |
|-------------|------|
| 全ドキュメントに信頼度ラベルが付与されている | ✅ |
| DB定義書はDDLとの機械的突き合わせが完了している | ✅ |
| 不足ドキュメントのリストが作成され、次ステップの方向性が決定している | ✅ |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

### 3.3 よくある落とし穴

- **信頼度ラベルの過信**: `[VERIFIED]` でも100%正確ではない。実装時に最終確認が必要
- **DDL突き合わせの省略**: 中核テーブルの欠落はDDL突き合わせでしか発見できない
- **「あるべき姿」の混入**: LLM生成ドキュメントには現行仕様と推奨事項が混在していることが多い

---

## 4. Step 2: 業務ロジック抽出

> **目的**: ソースコードから業務ロジックを抽出し、コード非依存の仕様書として文書化する

### 4.1 手順

#### 4.1.1 機械的抽出ツールの準備

仕様抽出の**前に**、以下のツールを準備する:

| ツール | 抽出対象 | 目的 |
|--------|---------|------|
| AST解析 | 関数名・引数・戻り値・クラス構造 | Ground Truth の確立 |
| モデル抽出 | dataclass/型ヒント | データ構造の機械的確認 |
| SQL抽出 | SQL文字列・テーブル名・CRUD種別 | データアクセスパターンの把握 |

**なぜツールが先か**: LLMの多段変換でハルシネーションが累積するリスクがある。機械的に抽出した事実（Ground Truth）があれば、LLM出力の正しさを検証できる。

**重要**: ツール自体のバグは Ground Truth を汚染する。**ツールにはテストを必ず書く**。

#### 4.1.2 仕様書の形式

仕様書は以下の構造で統一する:

```markdown
# モジュール名

> 信頼度: [DRAFT] → [VERIFIED]（突合完了後）

## ビジネスルール
### BR-XXX-001: ルール名（宣言的に記述）

## 定数・閾値

## テストシナリオ
```

**重要**: 仕様書はコード翻訳にならないこと。手続き的な記述（「for文で処理」）ではなく宣言的（「BR-001: 各従業員の残業時間は月次で集計される」）に記述する。

#### 4.1.3 並行処理戦略

依存関係のないモジュールは並行して仕様書を作成する。依存グラフの事前設計が実行速度を大幅に加速する。

```
Phase 1: 独立モジュール群（並行処理可能）
Phase 2: 相互独立のモジュール群（並行処理可能）
Phase 3: 統合モジュール（Phase 1-2 の出力に依存）
Phase 4: 横断検証（全仕様書に依存）
```

#### 4.1.4 VERIFIED 昇格プロセス

初回作成の仕様書は全て `[DRAFT]` とする。以下の手順で `[VERIFIED]` に昇格する:

1. **機械的抽出ツールの実行**: 関数シグネチャを抽出し、仕様書のビジネスルールと1:1対応を確認
2. **定数値の突合**: 仕様書に記載した定数値がソースコードの実際の値と一致することを確認
3. **最高リスク項目の手動読解**: 金額計算等の重要ロジックは全行手動読解で検証
4. **差分の記録**: 検証で発見した差分を全件記録し、修正が必要なものは即座に修正

> **例**: あるプロジェクトでは195+項目を検証し、差分26件を検出。うち4件は仕様書修正が必要だった。最高リスク項目（複合計算式：5係数・計算式・エッジケース3パス）は全行手動読解で完全一致を確認。

### 4.2 Gate 2: 仕様書完成

| チェック項目 | 必須 |
|-------------|------|
| 全仕様書が `[VERIFIED]` に昇格している | ✅ |
| 機械的抽出ツールでの突合が完了している | ✅ |
| 最高リスク項目は手動読解で検証されている | ✅ |
| 検証で発見した差分が全件記録されている | ✅ |
| 仕様書間の定数値一貫性チェックが完了している | ✅ |
| 依存マップが作成されている | ✅ |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

### 4.3 よくある落とし穴

- **構造検証だけで安心する**: 機械的検証は関数シグネチャを突合するが、関数内部の条件分岐は検証対象外
- **UI層ロジックの無視**: サービス層に集中しがち。UI層にはバリデーション・ボタン制御・表示切替等の暗黙的なロジックが存在する
- **縦割りのみの抽出**: 業務機能ごとに仕様書を作ると、同一テーブルへの参照パターンの不整合が見落とされる

---

## 5. Step 3: 設計（DB・アーキテクチャ）

> **目的**: 仕様書を基に新システムのDB設計・アーキテクチャ設計を行い、垂直スライスで疎通を確認する

### 5.1 手順

#### 5.1.1 DB設計

1. 現行スキーマの問題点リストアップ
2. 仕様書との依存関係整理（テーブル×ビジネスルールのマトリクス）
3. 設計方針の決定（型統一・命名規則・正規化方針等）
4. 新スキーマ設計（テーブル定義書・ER図・インデックス設計）
5. データ移行設計（カラムマッピング・型変換・クレンジング）

#### 5.1.2 アーキテクチャ設計

1. レイヤー構成の決定
2. 認証・認可方式の決定
3. API設計（エンドポイント一覧）
4. フロントエンド設計（コンポーネント構成・状態管理）
5. 横断的関心事（エラーハンドリング・ログ・テスト戦略）

#### 5.1.3 垂直スライス

設計の検証として、**最もシンプルな機能で全レイヤーを一気通貫で実装する**:

- 対象は**アーキテクチャ検証に最適な機能**を選ぶ（最も複雑な機能ではない）
- DB → BE → FE の全レイヤーを通す
- 認証フローを含める

> **例**: ある移行計画ではPoC対象を「最も複雑なモジュール」としていたが、実際には「認証+マスタCRUD」に変更。理由:「垂直スライスの目的はアーキテクチャ検証であり業務ロジック検証ではない」。業務ロジックはVERIFIED仕様書で担保済みで、残るリスクは技術スタックの動作検証だった。

### 5.2 Gate 3: 設計完了・垂直スライス疎通

| チェック項目 | 必須 |
|-------------|------|
| 新DBスキーマが設計されている | ✅ |
| アーキテクチャ設計が決定している | ✅ |
| 垂直スライスで全レイヤーの疎通が確認されている | ✅ |
| 認証フローが動作している | ✅ |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

### 5.3 よくある落とし穴

- **最も複雑な機能でPoCを実施する**: 最もシンプルなCRUDで全レイヤーを通してから業務ロジックを載せるべき
- **DB設計でDA調査を省略する**: テーブルの用途（読み取り専用か書き込みありか等）の追加調査で設計方針が大きく変わることがある
- **インフラ決定の先送り**: Async/Sync、ドライバ選択等の基盤的な技術決定は設計段階で確定すべき

---

## 6. Step 4: 横断検証

> **目的**: Step 1〜3 の成果物を横串で検証し、縦割り分析では見落とされる問題を発見する

### 6.1 なぜ横断検証が必要か

Step 2 で業務機能ごとに仕様書を作成すると、仕様書間の整合性が検証されない。以下の3領域で問題が持ち越されるリスクがある:

| 領域 | 典型的な問題 |
|------|------------|
| **データアクセスパターン** | 同一テーブルの参照日・境界条件がモジュール間で不統一 |
| **業務ワークフローの状態遷移** | 計算ロジックは仕様化されているが、状態遷移（承認フロー・締め処理等）が未記述 |
| **UI層の暗黙的ロジック** | サービス層の仕様は正確だが、UI層のバリデーション・表示制御が未仕様 |

### 6.2 横断検証チェックリスト

#### 6.2.1 データアクセスパターンの横断比較

| チェック項目 | 方法 |
|-------------|------|
| 同一テーブルの参照日が全仕様書で統一されているか | 各仕様書の WHERE 句パラメータ値を一覧化して比較 |
| 境界条件（`>` vs `>=`）が統一されているか | 比較演算子の一覧化 |
| フィルタ条件の適用が統一されているか | sql_extractor の結果を横断比較 |

#### 6.2.2 業務ワークフローの状態遷移

| チェック項目 | 方法 |
|-------------|------|
| 承認フローの状態遷移図が存在するか | Mermaid等で作成 |
| 締め処理等のワークフローが文書化されているか | 運用シナリオを網羅 |
| 状態遷移の各段階でのデータ変更権限が定義されているか | 状態×操作のマトリクス |

#### 6.2.3 UI層ロジックの検証

| チェック項目 | 方法 |
|-------------|------|
| バリデーションルールが仕様化されているか | submit/save 関数の全量精査 |
| ボタン制御ルールが仕様化されているか | UI コードの条件分岐確認 |
| 特殊値の扱いが仕様化されているか | UI層のデータ変換ロジック確認 |

### 6.3 Gate 4: 横断検証完了

| チェック項目 | 必須 |
|-------------|------|
| データアクセスパターンの横断比較チェックリストが全項目クリア | ✅ |
| 業務ワークフローの状態遷移図が主要フローについて作成されている | ✅ |
| UI層ロジックが仕様化されている | ✅ |
| DA批判レビューを実施し、少なくとも1件の問題を発見・対応している | ✅ |

### 6.4 よくある落とし穴

- **「仕様書ができたから横断検証は不要」**: 横断的な整合性は別途検証しないと見落とされる
- **計算ロジックだけに集中する**: 状態遷移とUI層ロジックは同等に重要
- **エラーハンドリングパターンの無視**: エラー時の挙動（サイレントスキップ等）も仕様化が必要

---

## 7. アンチパターン集

### AP-1: 業務機能の縦割り抽出のみで横断検証を省略する

**症状**: 各仕様書は個別には正確だが、仕様書間でデータアクセスパターンが不整合
**対策**: Step 4 の横断検証を必ず実施。同一テーブルの参照パラメータ値を全仕様書間で比較する

### AP-2: UI層ロジックを仕様抽出の対象外にする

**症状**: バックエンドの計算ロジックは正確だが、画面の入力制御・表示制御で差異が発生
**対策**: submit/save 関数のバリデーション全量精査を実施する。UIの条件分岐も仕様化する

### AP-3: 信頼度ラベルなしで次工程に進む

**症状**: 「だいたい合っているだろう」で設計に進み、後工程で手戻りが発生
**対策**: Gate 2 を厳守。ラベルのないドキュメントは `[UNVERIFIED]` 扱いにする

### AP-4: 機械的検証ツールなしで VERIFIED に昇格する

**症状**: LLMのハルシネーションをLLMでチェックしても同じ盲点を共有するリスク
**対策**: 機械的抽出ツールでの突合を VERIFIED 昇格の必須条件にする

### AP-5: 並行処理時の用語統一を怠る

**症状**: 複数スレッドで仕様書を並行生成すると、同じ概念に異なる用語を使用する
**対策**: 先に定数・用語の定義ファイルを作成し、全スレッドがそれを参照する

### AP-6: テストシナリオが仕様書ごとに閉じている

**症状**: 各仕様書のテストシナリオは正確だが、モジュール間の連鎖テストが不足
**対策**: 依存マップに基づいてE2E統合テストシナリオを設計する

---

## 8. 統合チェックリスト

全ゲートの統合チェックリスト。**実装フェーズに進む前に全項目がクリアされていること**を確認する。

### Step 0: 移行判断

- [ ] 移行方針が文書化されている
- [ ] 品質保証戦略が文書化されている
- [ ] DA批判レビューの義務化が合意されている
- [ ] 技術スタックの候補が決定している

### Step 1: ドキュメント棚卸し

- [ ] 全ドキュメントに信頼度ラベルが付与されている
- [ ] DB定義書はDDLとの機械的突き合わせが完了している
- [ ] 不足ドキュメントのリストが作成されている
- [ ] DA批判レビューで少なくとも1件の問題を発見・対応している

### Step 2: 業務ロジック抽出

- [ ] 機械的抽出ツールが準備されている（テスト付き）
- [ ] 全仕様書が `[VERIFIED]` に昇格している
- [ ] 機械的抽出ツールでの突合が完了している
- [ ] 最高リスク項目は手動読解で検証されている
- [ ] 検証差分が全件記録されている
- [ ] 仕様書間の定数値一貫性チェックが完了している
- [ ] 依存マップが作成されている
- [ ] DA批判レビューで少なくとも1件の問題を発見・対応している

### Step 3: 設計

- [ ] 新DBスキーマが設計されている
- [ ] アーキテクチャ設計が決定している
- [ ] 垂直スライスで全レイヤーの疎通が確認されている
- [ ] 認証フローが動作している
- [ ] DA批判レビューで少なくとも1件の問題を発見・対応している

### Step 4: 横断検証

- [ ] データアクセスパターンの横断比較が完了している
- [ ] 業務ワークフローの状態遷移図が作成されている
- [ ] UI層ロジックが仕様化されている
- [ ] DA批判レビューで少なくとも1件の問題を発見・対応している

## 関連リソース

| リソース | 用途 |
|---------|------|
| [GUIDE.md](../GUIDE.md) | 仕様抽出のクイックリファレンス（本マニュアルの要約版） |
| [sample_prompts/](../sample_prompts/) | 各ステップの DD 起票プロンプト + Gate チェックリスト統合版 |
| [references/lessons_learned.md](../references/lessons_learned.md) | 44DD以上の実践から得た教訓 |

---

*仕様書作成マニュアル（汎用版）— spec-know-how*
*作成日: 2026-02-19*
