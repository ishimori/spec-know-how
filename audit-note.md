# コードベース監査メモ

## コードベースルート・設定・依存関係など

### 環境

- Runtime (node) のバージョンが指定されていない
- パッケージマネージャの種類、バージョンが指定されていない
- 環境の再現性が存在しない

### 環境構築

- 手順に `npm install` が不足している
- 本番デプロイ方法が存在しない

### 依存関係

#### Next.js 15

- 最新版は 16
- 社内業務アプリにはオーバーキル/利点を活用できない可能性が高い (シンプルな SPA ルーターで良い)

#### Drizzle

- まだ v1.0 に達していないためプロダクションでは要注意

#### Auth.js

Auth.js は現在、新規プロジェクトには推奨されておらず、代わりに Better Auth を使用することが[推奨されています](https://authjs.dev/getting-started/migrate-to-better-auth)。

`"bcryptjs": "^3.0.3"` と `"@types/bcryptjs": "^2.4.6"` のバージョンが一致していない。

### 環境変数

`.env.test` で、シークレット (`AUTH_SECRET`) がリポジトリにコミットされている。(テスト用なので問題はほぼ無い)

もしコンテナ内でテストが実行される場合は、コンテナ上や CI 上で環境変数を設定可能。
あるいは、シークレットに明らかなダミーの値を利用するべき (`test-secret-do-not-use-in-production` のような)

### コード品質

- Linter (eslint など), Formatter (prettier など) がインストールされていない

## フレームワーク/ランタイム

### Next.js / Html レンダリング

- Next.js をフルスタックフレームワークとして使用
  - バックエンド API サーバーは別途存在しない
  - フロントエンドとバックエンドの両方を単一プロセスで担う
- 主にサーバーサイドレンダリング (SSR) による画面描画
  - React Query / SWR 等のデータフェッチライブラリは不使用
- App Router (React Server Components) を使用
  - 全 protected ページに `export const dynamic = 'force-dynamic'`
  - ナビゲーションは `<a href>` タグ (Next.js の `<Link>` ではない): **ページ遷移のたびにフルページリロードが発生する**
- Server Actions によるフォーム送信・ミューテーション処理
- API Routes による CSV エクスポート
- Middleware による認証ゲート

### ランタイムレイヤー

| 処理                 | 実行場所                  | 方式                                |
| -------------------- | ------------------------- | ----------------------------------- |
| ページ描画           | サーバー                  | Server Component (SSR)              |
| 認証ゲート           | サーバー (Edge + Node.js) | Middleware + Layout                 |
| データ取得           | サーバー                  | Server Component 内で直接 DB クエリ |
| フォーム送信         | サーバー                  | Server Actions                      |
| CSV エクスポート     | サーバー                  | API Route                           |
| フォーム操作 UI      | クライアント              | Client Component                    |
| セッション情報の表示 | サーバー                  | Layout で `await auth()` して描画   |

### 問題点

上記の構成は「Next.js を使っているが、Next.js を使うメリットをほぼ得ていない」状態にある。

- **SSR を使う意味がない**:
  - 全ページ `force-dynamic` で静的生成無し = Next.js のキャッシュ・ISR・静的生成が全て無効化
  - `<Link>` 不使用のためクライアントサイドナビゲーションも無効
  - ページ遷移のたびにフルリロード + サーバーで HTML を生成している (従来の PHP のような SSR MPA のようなもの)
  - リクエスト毎にサーバーサイドレンダリング + DB クエリが実行される
  - 認証済み内部アプリで SEO 不要のため、SSR による HTML 返却には実用的な利点がない
  - クライアント側の状態管理が存在しないため、楽観的更新 (Optimistic UI) やクライアントキャッシュが不可能
- **フルスタック一体型のリスク**:
  - フロントエンドとバックエンドが同一プロセスで動作するため、フロントを変更するだけでもバックエンド含む全体の再デプロイが必要
  - データベースヘビーではないアプリ向けの構成を利用している状態
  - フロントとバックのスケーリング要件が異なる場合に独立してスケールできない
- **Next.js の複雑さだけを負担している**:
  - App Router, Server Components, Edge Middleware, Server Actions など Next.js 固有の概念を多数抱えているが、この業務アプリの要件 (認証付き CRUD) に対してはオーバーキル。学習コスト・デバッグコスト・バージョンアップ追従コストが不必要に高い

結果として、React / Next.js App Router の複雑さ (Server Components, Server Actions, Edge Middleware, JWT Cookie, etc.) だけを抱えつつ、そのメリット (SPA的なスムーズ遷移、プリフェッチ、差分更新、キャッシュ) を一切享受していない。

### 本来どうあるべきか

SPA + 独立バックエンド API (あるいは軽量 SSR フレームワーク) の構成を利用するべき。

- 認証を含む内部アプリの場合、React SPA (Vite + TanStack Router 等) + 軽量 API サーバー (Hono/Fastify 等) の方が適切
- Next.js を使うなら Next.js の利点を活かすべきだが、認証の背後でキャッシュを適切に管理するのは難しい
- データベースへのアクセスは API レイヤーを経由させ、認証・認可・接続数管理を集約すべき。フロントエンドから直接 DB に接続する設計は本番運用に適さない

## データベース

### マイグレーション

- FK の ON DELETE / ON UPDATE がすべて `no action` (= `RESTRICT`) で `CASCADE` が一切使われていない
- 本番環境へのマイグレーション適用手順が未定義
- マイグレーションのロールバックが未定義

### Seeding

- `seed.ts` と `seed-e2e.ts` (E2E テスト用) の 2 ファイル
- 単一ファイルにすべてが含まれているため、柔軟に seed を実行できない
- seed を実行すると、**全データが削除される。**
- 本番環境での実行を防止するガードが存在しない (そもそも本番環境でも実行することを想定している？)
- seed ファイルが独自のコネクションプールを作成しており、`db/index.ts` のシングルトンを使っていない

### スクリプト

```json
"db:seed": "node --env-file=.env.local node_modules/tsx/dist/cli.mjs src/db/seed.ts",
"db:generate": "node --env-file=.env.local node_modules/drizzle-kit/bin.cjs generate",
"db:migrate": "node --env-file=.env.local node_modules/drizzle-kit/bin.cjs migrate",
"db:studio": "node --env-file=.env.local node_modules/drizzle-kit/bin.cjs studio",
"db:seed:e2e": "node --env-file=.env.test node_modules/tsx/dist/cli.mjs src/db/seed-e2e.ts"
```

問題:

- `node_modules/<pkg>/<script>.js` でパッケージの内部パスを直接指定している。代わりに `npx` を使用するべき。
- スクリプトは `.env.local` (ローカル環境用) をハードコードしているため、別環境で利用できない。
- テスト DB (`kvmanage_test`) へのマイグレーション用スクリプトが存在しない (PLAYWRIGHT.md のドキュメントでは `db:migrate` が `.env.test` を使うと記載されているが、実際は `.env.local`)
- 本番環境でのマイグレーション実行方法が未定義

### スキーマ

```tsx
export const depts = mysqlTable(
  'depts',
  {
    id: int('id').primaryKey().autoincrement(),
...
```

非推奨としてマークされている方法で `mysqlTable` を使用している。

### 柔軟性

- リポジトリ / サービス層が存在しないため、すべてのデータアクセスが Server Actions / Page Components に直接散在。テーブル構造の変更時、影響範囲の特定が困難
- マスタデータ (employees, depts) と業務データ (stamps, keys) のアクセスパターンが同一のため、マスタデータを中央 DB サービスから取得する設計に移行する場合、全ファイルの改修が必要
- Drizzle ORM の型がアプリケーション全体に漏れている。ORM の変更・置換が極めて困難。
- Drizzle ORM の MySQL 固有 API がアプリケーション全体に浸透しているため、DB エンジンの置換は事実上不可能
- データアクセスの抽象化がないため、データストアやデータプロバイダーの置換には全ファイルの改修が必要
- `makeSelectChain()` 等のヘルパーが Drizzle の `.from().where().orderBy()` チェーンを再現しており、ORM のバージョンアップや API 変更でテストが壊れる

### データベース設定

- **`DATABASE_URL` の non-null assertion (`!`)**: 環境変数が未設定の場合 `undefined` が `mysql.createPool` に渡され、不明瞭なエラーになる
- **コネクションプールのクローズ処理がない**: アプリケーション (Next.js) 側で `pool.end()` のようなグレースフルシャットダウンが未実装
- **`connectionLimit: 10` がハードコード**: 本番環境のスケーリング要件に応じて調整が必要だが、環境変数等で設定変更不可
- 本番環境のコメントに「毎回新規作成」と記載されているが、実際は Node.js のモジュールキャッシュによりシングルトン

### アプリケーションの DB 依存度

- レンダリング用のファイルが `db` シングルトンを直接 import し、Drizzle ORM の Query Builder API をインラインで使用
- Page コンポーネント (React Server Components) が直接 DB クエリを実行: 表示層とデータ層が完全に密結合
- Server Actions で、 DB トランザクション/クエリロジック/ビジネスバリデーション/レスポンス返却などが 1 関数内で混在
- データアクセスを抽象化し、リポジトリやサービス層を導入することで、DB 依存を集中管理するべきである

### アーキテクチャ上の課題

- **関心の分離が欠如**: データアクセス・ビジネスロジック・プレゼンテーションが分離されていない
- **トランザクション境界が不適切**: `editKeyGroup`, `deleteKeyGroup`, `returnKey`, `cancelledAssignKey`, `closing`, `unclosing` など、同時操作時にデータ不整合リスク

## 認証

[src/auth.ts](../src/auth.ts) で認証ロジックを再実装しているが、既存の実装済みの認証ソリューションを活用した方が良い。(認証のような複雑で難しいタスクは車輪の再発明をするべきではない。Auth.js のようなライブラリを使用するメリットをすべて無視している)

これにより以下のようなデメリットがあります:

- Auth.js のようなライブラリによって実装されている保護機能が全てスキップされる。
- 新しい認証内のロジックを追加したい場合や、中央認証サーバーによる Single Sign-On を実装したい場合などに、移行や実装が困難になる。

また、ログイン後のセッション維持方法が jwt による stateless のため (データベース stateful セッションではない)、ログイン後セッションが切れるまでユーザー情報のデータベースの変更が反映されない。
つまり、ユーザーの権限を変更しても元の権限でアプリケーションを利用できる。

- **`auth.ts` の `authorize()` に try/catch がない**: DB 接続失敗時のエラーが不明瞭なまま Auth.js フレームワークに伝播

## テスト

### ユニットテスト

- 実際にはユニットテストではない (モック統合テスト) テストもユニットテストに分類されている
- 未テストのコードが多数ある
- コードの大部分が純粋関数でなく、ビジネスロジックと IO が分離されていないため、テスト可能なコードが少ない
- いくつかのテスト実装はテスト価値が低い
- Server Actions のテストはテストケースが少ない上に、大部分がモックに強く依存しているため壊れる可能性が高い
- `src/lib/constants.ts` と `src/types/constants.ts` で定数が重複している

### E2E テスト

- テスト用環境の定義が存在しない。テストが開発環境や本番環境を壊す可能性がある
- テスト間の依存が存在する
- 環境を手動で構築しなければならない (`PLAYWRIGHT.md` は存在してはならない)
- 本来は、**再現性の高い宣言的環境セットアップ** (docker-compose, スクリプト, CI パイプライン等) が必要
- テストは Turbopack dev server 上で実行されるべきではない
- E2E テストは壊れやすいため、大きく依存するべきではない。

## LLM が生成したドキュメント

LLM が生成したドキュメントのほとんどはデタラメで無意味なものとなっている。

### 例 - DD-048-2_技術スタック決定（ADR-003確定）.md

[DD-048-2_技術スタック決定（ADR-003確定）.md](../doc/archived/DD/DD-048-2_技術スタック決定（ADR-003確定）.md)

```markdown
### 採用技術スタック

| 区分                         | 採用技術                     | バージョン          |
| ---------------------------- | ---------------------------- | ------------------- |
| バックエンドフレームワーク   | **Next.js (App Router)**     | 15.x                |
| 認証                         | **Auth.js (NextAuth.js v5)** | 5.x                 |
```

- Next.js は要件に対して明らかにオーバーキルであり、Next.js の特徴を活用できる要件でもない
- Auth.js は公式に Better Auth への移行を推奨している。バージョン 5 はまだベータチャンネルである。

```markdown
## なぜこの構成が「LLM に最適化」されているか

### 1. FE/BE の同一ファイル内コロケーション（Next.js App Router）

app/
  stamps/
    [syz_code]/
      page.tsx          ← Server Component（DB からデータ取得）
      actions.ts        ← Server Actions（フォーム送信処理）
      schema.ts         ← Zod スキーマ（バリデーション）

- LLM が「1画面 = 1ディレクトリ」の単位で FE/BE を一度に理解・生成できる
- PHP + CakePHP のようにコントローラー・ビュー・モデルが分散しない
```

- コンポーネント内にビジネスロジックや IO アクセスは**絶対に含めないべきである**
- 要件に対して、Next.js App Router は全く適切ではない
- End-to-End タイプセーフの意味を勘違いしている
  - 「End-to-End タイプセーフにしてください」ではなく、具体的な方法を指示しなければならない。
- LLM はそもそも「LLM に最適化された構成」を知らない (考えることができない) ため、ただデタラメをでっち上げているだけ
  - 「LLM に最適化された構成にしてください」ではなく、具体的な方法を指示しなければならない
- 皮肉にもこの設計はフレームワークを使用しないレガシーでアンチパターンの PHP コードベースと酷似している

```markdown
### 2. 型安全な End-to-End（TypeScript + Drizzle ORM + Zod）

Drizzle schema（TypeScript で直接定義）
  → TypeScript 型（自動推論・生成不要）
    → Zod バリデーション（一致）
      → React props（型安全）
        → DB クエリ（型安全・SQL に近い記法）

- LLM が「型」を手がかりに全レイヤーの整合性を維持しながらコードを生成できる
- Drizzle は `schema.prisma` という独自言語がなく、**TypeScript だけで完結**する
```

- Next.js App Router は End-to-End タイプセーフのためのものではない
- End-to-End タイプセーフとは、「スキーマファーストあるいはコードファーストで生成した型ファイルをサーバーからフロントエンドに共有する」という意味である
- 階層図が意味不明

```markdown
### 3. 訓練データの密度（LLM 精度の直接的な根拠）

| 技術                 | GitHub 公開コード量             | LLM 生成精度 |
| -------------------- | ------------------------------- | ------------ |
| Next.js + TypeScript | 非常に多い（デファクト標準）    | 高           |
| Tailwind CSS         | 非常に多い                      | 高           |
| Drizzle ORM          | 増加中（2024〜2025年で急拡大）  | 高           |
| DaisyUI              | 多い（Tailwind ベースで直感的） | 高           |
| CakePHP 3.x          | 少ない（EOL後は急減）           | 低           |
```

- プロンプトを満足させるためだけの全く無意味な情報

```markdown
## DA批判レビュー記録

### Phase 0 DA批判レビュー

**DA観点:** 「この技術スタック検討に抜け・罠はないか？」

| #   | 発見した問題/改善点                                                                                                                           | 重要度 | DA観点               | 対応                                                                                                             |
| --- | --------------------------------------------------------------------------------------------------------------------------------------------- | ------ | -------------------- | ---------------------------------------------------------------------------------------------------------------- |
| 1   | ホスティング環境が PHP 5.6 対応のサーバーだった場合、Node.js 実行環境が使えない可能性がある                                                   | 高     | 前提条件の欠落       | Phase 2 で「本番サーバーの Node.js 実行環境確認」をタスクに追加すること                                          |
| 2   | CakePHP 3 の Fixture ベースのテストと Vitest + Prisma Seed のテストは設計思想が根本的に異なる。旧テストコードは全て書き直しが必要（移植不可） | 高     | 移行コストの過小評価 | DD-048-5（垂直スライス）で Vitest + Prisma Seed の動作確認を優先し、テスト設計パターンを確立してから本格移植する |

### Phase 1 DA批判レビュー

**DA観点:** 「Next.js / TypeScript 採用の判断に問題はないか？」

| #   | 発見した問題/改善点                                                                                                                                                                 | 重要度 | DA観点               | 対応                                                                                                                     |
| --- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ | -------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| 1   | Next.js App Router は学習曲線がある（Server Components vs Client Components の判断、Server Actions の制約等）。PHP/CakePHP チームがゼロから学習する場合、初速が遅くなるリスクがある | 中     | 学習コストの過小評価 | DD-048-5（垂直スライス PoC）で実際の開発速度を測定し、学習コストを早期に可視化すること                                   |
| 2   | Tailwind CSS v4 は 2025年初頭リリースで、まだ破壊的変更のリスクが残る。v3 の方が情報量・安定性が高い可能性がある                                                                    | 低     | 技術の成熟度リスク   | v4 の安定性を確認し、問題があれば v3 にダウングレードする。初期は `@tailwindcss/vite` プラグインの対応状況も確認すること |

### Phase 2 DA批判レビュー

**DA観点:** 「coding-guide.md と nfr.md の作成内容に問題はないか？」

| #   | 発見した問題/改善点                                                                                                                                                                                                                                                                   | 重要度 | DA観点                       | 対応                                                                                                                                                                                 |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ | ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1   | `coding-guide.md` の Server Actions テンプレートで `count` サーバー側再計算を必須としているが、鍵管理業務には `count` フィールドが存在しない。Keys ドメインに不適切なルールが適用されるリスクがある                                                                                   | 中     | ドメイン固有ルールの過剰汎化 | coding-guide.md 内のコメントで「count 再計算は Stamps ドメインのみ」と明記済み。Keys の Server Actions テンプレートは DD-048-4（アーキテクチャ設計）で別途定義すること               |
| 2   | `nfr.md` の URL 設計（section 2.1）では `[syzCode]` が URL パラメータだが、`STORE` ロールのユーザーはセッションに固定の `syzCode` を持つ。URL に `syzCode` を含める設計は必要か？ログイン後に `/stamps` にリダイレクトしてセッションの `syzCode` を使う設計の方がシンプルかもしれない | 低     | URL 設計の必要性疑問         | 旧システムも syz_code を URL に持つ設計であり、BRANCH/DRUG/LINE が複数店舗を切り替えるためには URL パラメータが必要。DD-048-4 のアーキテクチャ設計でルーティング詳細を再検討すること |
```

- これらのレビューの内容はすべて本質的ではなく全くの無意味

同様にすべてのドキュメントが以下のような "LLM Slop" になっている:

- 無意味で冗長な表現
- 一見それっぽく見える専門用語を多用しているだけで、中身はなく意図や本質や意味が不足している
- プロンプトを満たすためだけの嘘

## "エラーを隠す" ハック

最近のモデルによく見られる「エラーを隠すハック」の例。

```ts
function createDb() {
  const pool = mysql.createPool({
    uri: process.env.DATABASE_URL!, // 適切なチェックをせず、non-null assertion で静的に検出可能なエラーを隠している
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0,
  })
  return drizzle(pool, { schema, mode: 'default' })
}
```

```ts
// zod をインストールしているにも関わらず、ランタイムチェックを行わずに型を assertion している
const syainCode = credentials?.syainCode as string | undefined
const password = credentials?.password as string | undefined
```

```ts
// eslint はインストールされていないにも関わらず、`eslint-disable` コメントを追加している
declare global {
  // eslint-disable-next-line no-var
  var __drizzleDb: ReturnType<typeof drizzle> | undefined
}
```

LLM は「ソフトウェアエンジニアリングについて何も知らない人々」「コードを見ない人々」をターゲットにしているため、コードの品質よりも、いかにランタイムでエラーを発生させないコードを書くか (= エラーを背後に隠して問題なく動作しているように見せるコード) の方向で成長しています。

つまり、「正しいが間違えるとエラーが発生するコード (これは適切な挙動。エラーは間違いを検出するためにある)」よりも、「エラーが発生しない間違ったコード」を優先するということです。

この傾向は過学習しているため、プロンプトでも制御できなくなっている点に注意してください。

## まとめ

現時点ですでに、土台がボロボロであり、アプリ自体もスパゲティで奇跡的に成り立っている状況。
積極的にエラーが隠されている可能性が高い。

仕様変更や拡張、あるいは不具合修正ですら困難になることが予想される。
どこかを変更したら、別の場所に不具合が発生するのようなことが起きる可能性が非常に高い。
つまり、保守性は非常に悪い。(保守性は現行のアプリよりも悪い可能性がある)
レガシーな PHP アプリのような状態になっている。

LLM が生成したドキュメントはすべて無意味に見える。
