# LLM 生成コードを使う際に知っておきたいこと

LLM を活用した開発は生産性を大きく高めます。一方で、LLM 固有の特性から生じる落とし穴があり、それを知らずに進めると後から気づきにくい問題が積み重なります。このドキュメントでは、LLM 生成コードのレビューで繰り返し見られるパターンを整理します。

---

## 1. 技術選定の落とし穴

LLM は「訓練データに多く含まれている組み合わせ」を提案します。これは必ずしも「あなたの要件に最適な選択」ではありません。

### よく見られるパターン

**フレームワークの過剰採用**

LLM は Next.js、NestJS、Spring Boot などのフルスタックフレームワークを積極的に提案しがちです。しかし、認証付きの社内 CRUD アプリのように要件がシンプルな場合、フレームワークの恩恵（キャッシュ、SSR、ISR など）を実際には一切使わないまま、その複雑さだけを背負う構成になることがあります。

使いたいフレームワークの利点を実際に活かせているか、選定後に確認することを推奨します。

**依存ライブラリのバージョン選択**

LLM は「よく見かけるバージョン」や「訓練データ時点での安定版」を使う傾向があります。次のような点を人間が確認してください。

- メジャーバージョンが現行と乖離していないか
- プロダクションで使うには未成熟なライブラリ（v1.0 未満など）が含まれていないか
- 公式が移行を推奨しているライブラリを使い続けていないか（例：認証ライブラリが後継製品への移行を案内している場合）

**環境の再現性**

LLM はコードを書くことに集中しがちで、以下を省略しやすいです。

- ランタイム（Node.js など）のバージョン指定
- パッケージマネージャのバージョン指定
- 環境構築手順（`npm install` の記載漏れなど）

プロジェクト開始時に環境再現性を明示的に指示するか、後からチェックリストで確認することを推奨します。

---

## 2. 「エラーが出ない = 正しい」ではない

LLM には構造的な傾向として、**実行時エラーを発生させないコードを優先する**特性があります。「コードを見ない人々」や「ソフトウェアエンジニアリングに不慣れな人々」向けに最適化されているためと考えられます。

これにより、**本来エラーとして顕在化すべき問題が静かに隠れたコード**が生成されやすくなります。

### よく見られるパターン

**Non-null assertion の乱用**

環境変数が未設定の場合に備えたガードを書かず、`!` による non-null assertion でコンパイルエラーを回避するコードが生成されやすいです。実際の実行時には不明瞭なエラーが発生しますが、静的解析では見えません。

**型 assertion による検証のスキップ**

バリデーションライブラリ（Zod など）がインストールされているにもかかわらず、ランタイムチェックを行わずに型 assertion だけで済ませるパターンがあります。入力値の検証が実質的に無効化されます。

**インストールされていないツールへの参照**

Linter がインストールされていない環境で `eslint-disable` コメントを挿入するなど、存在しないツールへの参照が生成されることがあります。レビュー時に依存関係と実際のコードの整合性を確認してください。

**接続・シャットダウン処理の省略**

データベース接続プールのクローズ処理など、エラーには直結しにくいが本番運用に必要なコードが省略されやすいです。

---

## 3. LLM 生成ドキュメントの特性

コードと同様に、LLM が生成したドキュメントにも固有の落とし穴があります。

### 「もっともらしさ」と「正確さ」は別物

LLM はプロンプトに応じて一貫性のある文章を生成しますが、**プロンプトを満足させることが目的**であり、内容の正確さは二次的です。生成されたドキュメントには次のような傾向があります。

- 専門用語が多用され、一見して権威があるように見えるが、内容が薄い
- 根拠のない数値や比較表が挿入されている
- 「なぜこの選択か」という意図や根拠が欠如している

### 自己参照的な誤り

LLM は「LLM に最適化された設計」「LLM フレンドリーな構成」といった概念を、根拠なく肯定的に説明しがちです。LLM 自身は「LLM に最適な構成」を定義できる立場にありません。このような表現が含まれているドキュメントは、内容を慎重に検証してください。

### レビューの偽装

LLM にレビューを依頼すると、「批判的なレビューをした体裁」のコンテンツを生成することがありますが、指摘内容が本質を突いていないことがほとんどです。本物のエンジニアリングレビューの代替にはなりません。

---

## 4. アーキテクチャへの影響

LLM が生成する構成は「動く」ことが多いですが、保守・拡張・運用の観点では課題を抱えやすいです。

### データベース層

- **関心の分離がない**: ページコンポーネントやアクション関数に DB クエリが直接散在し、テーブル構造を変更したときの影響範囲が把握しにくくなります。リポジトリ層やサービス層の導入を検討してください。
- **データ整合性の設計漏れ**: FK 制約の CASCADE 設定、トランザクション境界の設計など、同時操作時のデータ不整合リスクへの対処が省略されやすいです。
- **危険なスクリプトの生成**: seed スクリプトに本番環境実行ガードがない、マイグレーションのロールバック手順が未定義、といったケースがあります。

### 認証

LLM は既存の認証ライブラリの内部ロジックを独自に再実装するコードを生成することがあります。これにより、ライブラリが提供するセキュリティ上の保護が全てバイパスされます。認証のような複雑なドメインは、実績のある外部ライブラリに委ねることを強く推奨します。

また、ステートレスな JWT セッションを採用した場合、権限変更がセッション切れまで反映されないといった業務上の問題が生じることがあります。要件を明示的に伝えなければ、LLM は一般的なパターンを採用します。

### テスト

- ユニットテストとモック統合テストが混在し、テスト戦略が曖昧になりやすいです
- ビジネスロジックと IO が密結合しているため、純粋なユニットテストが書きにくい構造になりがちです
- E2E テストの環境依存が高くなり、再現性のある実行が困難になることがあります

---

## 5. LLM をうまく使うために

上記の落とし穴は、LLM の価値を否定するものではありません。これらを知った上で使うことで、LLM の恩恵を最大化できます。

### 具体的な指示で精度を上げる

「LLM フレンドリーな構成にしてください」「End-to-End タイプセーフにしてください」のような抽象的な指示は、LLM が独自の解釈で埋めてしまいます。**「どのような構成か」を具体的に指示する**ことで、意図通りの出力が得られやすくなります。

### 人間によるゲートレビューを組み込む

LLM 生成物は、必ず人間のエンジニアがレビューするプロセスを設けてください。特に以下は重点的に確認することを推奨します。

- 技術選定と要件の適合性
- エラーハンドリングと異常系の処理
- セキュリティ上の設計（認証・認可・入力検証）
- DB 設計と整合性保護

本リポジトリの [GUIDE_SPEC.md](GUIDE_SPEC.md) および [GUIDE_IMPL.md](GUIDE_IMPL.md) に記載されているゲートチェックリストは、このレビューを体系化するためのものです。

### ドキュメントは生成後に検証する

LLM が生成したドキュメントは「それっぽい」が「正しいかどうかは別」と考えてください。技術的な根拠・意図・前提条件を人間が書き足すことで、初めて実用的なドキュメントになります。
