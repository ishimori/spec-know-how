# 05. 気付きと教訓

> **状態**: 記載中。プロジェクト進行に合わせて随時追記する。
> **反映DD**: DD-001〜DD-036（最終更新: 2026-02-15）

| セクション | 対象DD | 追記日 |
|-----------|--------|--------|
| Phase 1 気付き (#1〜#6) | DD-001〜DD-010 | 初版 |
| Phase 2 気付き (#7〜#8) | DD-011〜DD-013 | 初版 |
| うまくいかなかった点 (#1〜#2) | DD-001〜DD-013 | 初版 |
| 画面量産フェーズ (#9〜#10) | DD-014〜DD-024 | 2026-02-15 |
| 基盤設計 (#11〜#12) | DD-025〜DD-031 | 2026-02-15 |
| 新機能実装 (#13〜#15) | DD-032〜DD-036 | 2026-02-15 |
| うまくいかなかった点 (#3) | DD-018, DD-022, DD-029 | 2026-02-15 |

---

## Phase 1 で得られた気付き

### 1. AI が書き、AI が検証し、AI が読む — 一貫したループが鍵

今回最もうまくいった要因は、ドキュメントの**生産者と消費者が同じ AI** であることだ。

```
AI がコードを読んで仕様書を書く
AI がツールで仕様書とコードを突合検証する
AI が仕様書を読んで質問に回答する
```

人間が書いた自然言語ドキュメントは、AI にとって曖昧さの塊になりがちである。しかし AI 自身が構造化ルール（BR-xxx 採番、定数の一元管理、検証記録の形式）に従って書いた仕様書は、AI が正確に検索・引用できる。

**教訓**: AI に読ませるドキュメントは、AI に書かせるのが最も効率的かつ正確。

### 2. 「信頼度ラベル」は思った以上に重要

[VERIFIED] / [DRAFT] の2段階ラベルを導入したことで、以下の効果があった:

- **QA 回答の信頼度が明示される**: 「この回答は VERIFIED 仕様書に基づいています」
- **作業の優先順位が明確になる**: DRAFT は使う前に検証が必要、という判断が即座にできる
- **検証の進捗が可視化される**: 10本中何本が VERIFIED か、で品質が数値化できる

**教訓**: ドキュメントには必ず信頼度ラベルをつけよ。「ドキュメントがある」と「信頼できるドキュメントがある」は全く違う。

### 3. 仕様書に「差分」を残すことの価値

仕様書とコードの突合で見つかった差分を「修正して終わり」にせず、**差分・修正セクションに記録した**ことが後から役立った。

例:
- 「ソースコードの docstring に旧仕様(C1d x 25h)が残っている。実装は固定額」→ 移行時にこの docstring に惑わされずに済む
- 「E12 のバックエンド参照キーが不一致」→ 潜在バグとして移行先で修正すべき項目が明確

**教訓**: 差分は消さずに記録せよ。「なぜ差分が生まれたか」の注記が、将来の意思決定を助ける。

### 4. 定数の一元管理は仕様書でも効く

プログラミングの原則「Don't Repeat Yourself」は仕様書にも適用できた。

- `00_constants.md` に全定数を集約し、各仕様書は「→ 00_constants.md 参照」とだけ書く
- 定数値が変わっても修正箇所は 1 箇所

**教訓**: 仕様書でも DRY 原則を守れ。同じ数値を複数の仕様書に書くと、不整合の温床になる。

### 5. QA スキルの「賢さ」はドキュメント構造に依存する

QA スキル自体にはインテリジェンスはない。やっていることは:

1. キーワード→仕様書のマッピング表で対象ファイルを特定
2. ファイルを Read して該当ルールを抽出
3. 移行元コードを Grep/Read して裏取り

この**極めてシンプルな仕組み**が高精度で機能するのは、仕様書が以下を満たしているからだ:

- BR-xxx で一意にルールを特定できる
- 計算式が曖昧さなく書かれている
- 検証記録で信頼性が担保されている
- CLAUDE.md にインデックス（ドキュメントマップ）がある

**教訓**: AI ツールの性能を引き出すのは、ツール自体の複雑さではなく、それが読むデータの質。

### 6. 「移行のために作った仕様書」は移行後も価値を持つ

当初は「移行プロジェクトの中間成果物」として仕様書を作ったが、完成してみると:

- 顧客からの仕様問い合わせに即答できる
- 新メンバーのオンボーディングに使える
- 監査時の計算ロジック説明資料になる
- 仕様変更時の影響範囲分析ができる（依存マップ）

**教訓**: コードの真実を構造化した仕様書は、作った目的を超えて長期的に価値を持つ。「移行のため」だけに作るのはもったいない。

---

## うまくいかなかった点・改善余地

### 1. 画面仕様・UI 仕様のカバー不足

業務ロジックの仕様書は高品質で作れたが、画面のアクセス制御やUI仕様（どの画面がどの権限で見えるか）は仕様書化が不十分だった。

**原因**: 画面仕様は `menu_def.yaml` や `main.py` のコードに散在しており、業務ロジックのような独立した関数として抽出しにくかった。

**改善案**: 画面×権限マトリクスのような定型フォーマットを先に定義し、そこにコードから埋めていく方式にする。

### 2. マスタデータの具体値が不明

DB テーブル定義は抽出できたが、マスタデータの具体値（例: `system_role` テーブルにどんなロール名が入っているか）はコードからは取得できない。

**改善案**: 本番 DB のマスタデータダンプ（個人情報除外）を取り込み、仕様書に反映する工程を追加する。

### 3. ロール名の日英不一致が横断的な権限バグを生んだ

DBの `role_name`（日本語: 一般社員、店舗責任者、総務部）と FE/BE のロール定数（英語: STAFF, MANAGER, HR）が不一致だった。`is_all_priv=true` のロール（役員、総務部）では特権により問題が隠蔽され、`is_all_priv=false` の店舗責任者でのみバグが顕在化した。

この問題は DD-018（有休残確認画面）で初めて発見され、DD-022 で3画面の横断修正を行い、DD-029 で `role_code` カラムの追加による根本解決に至った。解決までに3つのDDを要した。

**原因**: これはまさに上記 #2（マスタデータの具体値が不明）の具体的帰結である。`system_role` テーブルの中身を仕様書に反映していれば、日英不一致は仕様抽出の時点で発見できた。

**教訓**: システム内部の識別子は一貫した命名体系を持つべき。特に多言語環境では、表示用ラベル（日本語）と内部コード（英語）の分離を設計段階で強制する仕組みが必要。

---

## Phase 2 で得られた気付き

### 7. 「計算ロジック」だけが業務ロジックではない

Phase 1 の仕様抽出（DD-003）では残業計算・歩合計算・有休管理など**計算系ロジック**を中心に抽出した。しかし Phase 2 で画面実装（DD-011〜DD-012）を進めたところ、移行元の `check_submit()` に埋まっていた**バリデーションロジック 12 条件**が丸ごと未移植であることが判明した（DD-013）。

原因は複合的だった:

1. **抽出スコープの偏り**: DD-003 は DB 層や計算関数を調査対象にしており、UI 層（`tab_daily.py`）に混在するビジネスルールが視界外だった
2. **DD スコープの偏り**: DD-011/012 は「画面を作る」にフォーカスしており、「この画面が守るべきルールは何か」が起点になっていなかった
3. **偽の完了感**: 基本バリデーション（HH:MM 形式、始業<終業）を実装した時点で「バリデーション完了」の感覚が生まれ、移行元との全量突合を怠った

**教訓**: バリデーションは「計算」ほど目立たないが、業務的には同等に重要なロジックである。画面を実装する DD では、Phase 0 で**移行元の submit/save 関数を必ず全量精査**し、「UI を作る」と「ルールを移植する」を明示的に分離すべき。

**対応**: DD テンプレートの Phase 0 に「移行元コード突合」ステップを追加し、CLAUDE.md にも画面実装 DD のルールとして明記した。

### 8. 移行元の画面構成を忠実に再現してはいけない

DD-011 で勤怠入力画面を実装した際、移行元 Streamlit の**4タブ構成**（日次入力 / 月次一覧 / 週次サマリー / 月次集計）をそのまま React に踏襲した。結果、各タブの情報密度が極端に低く（週次集計は5行のテーブルで1画面を占有）、React の画面表示能力を全く活かせていなかった。

DD-012 で再設計し、**タブを完全廃止して1画面に統合**。フル幅テーブルでのインライン編集に転換した。

| 観点 | Streamlit（DD-011） | React（DD-012） |
|------|---------------------|-----------------|
| 画面構成 | タブ分割が必須（ウィジェット配置の制約） | 自由なレイアウト |
| 情報密度 | 各タブが独立 → 低密度 | 1画面に統合 → 高密度 |
| 操作パラダイム | タブ切替 → フォーム入力 | テーブル行クリック → インライン編集 |
| 文脈維持 | タブ間で文脈が切れる | 月次一覧を見ながら編集 |

**根本原因**: 仕様書から「画面の機能的な要件（何ができるか）」を抽出する段階で、「画面の構成（どう見せるか）」まで一緒に引き写してしまった。機能要件と UI パラダイムを分離する意識が不足していた。

**教訓**: フレームワーク移行では、**機能的な仕様**（入力項目・計算ルール・業務フロー）は忠実に移植すべきだが、**UIパラダイム**（画面構成・操作動線・情報配置）は移行先の強みに合わせて再設計すべき。「何ができるか」と「どう見せるか」を明確に分離せよ。

---

## 画面量産フェーズで得られた気付き（DD-014〜DD-024）

### 9. 定型パターンの確立が量産速度を決める

DD-014（申請承認画面）で確立した**4層パイプライン**が、その後の8画面（DD-015〜DD-021）の短期量産を可能にした。

```
BE: Model → Repository → Service → Router
FE: 型定義 → API関数 → React Queryフック → コンポーネント
```

DD-014 では権限チェック、ページネーション、Excel出力などの**共通パターンを意識的に設計**した。その結果、DD-015 以降の画面は「パターンの適用」だけで実装が完了し、新たな設計判断がほぼ不要になった。Excel出力ひとつ取っても、ヘッダー色・フリーズペイン・フィルタ設定をテンプレート化したことで、毎回の試行錯誤がなくなった。

**教訓**: AI主導開発では「最初の1画面」にパターン確立の時間をかけるべき。2画面目以降はパターン適用で桁違いに速くなる。パターンは暗黙知にせず、コード構造として定着させよ。

### 10. 横断品質レビューは個別DDでは見えない問題を炙り出す

個別DDでは「完了」扱いだった画面群に、横断レビューで多数の問題が見つかった。

| 発見の契機 | 内容 | 影響範囲 |
|-----------|------|---------|
| DD-018 DA批判レビュー | HRロールが店舗フィルタを使えない | 3画面（DD-022で横断修正） |
| DD-024 総合レビュー | Excel Formula Injection、権限チェック漏れ | 9画面・426テスト |
| DD-036 5ラウンド分析 | 部分失敗時のstate不整合、仮締めワークフロー破壊 | 売上機能全体・34件 |

特にDD-022は象徴的だった。DD-018のDA批判レビューで「HRロールが店舗フィルタを使えない」バグを1画面で発見したが、調査すると**全く同じパターンのバグが3画面に存在**していた。個別DDのスコープでは「この画面は動く」で完了するが、横断的に見ると同じ設計ミスが複数画面に伝播している。

**教訓**: 高速量産のあとには必ず**横断レビューDD**を設けよ。「完了」した個別DDの品質を信頼しすぎてはいけない。量産で生まれたパターンにバグがあれば、全画面に伝播している。

---

## AI主導開発の基盤設計で得られた気付き（DD-025〜DD-031）

### 11. AI に「自分の環境を見る目」を与えよ

DD-026で開発効率化ツールチェーンを整備した。AIが書いたコードの結果（環境の状態）をAI自身が確認できる仕組みである。

| ツール | 役割 |
|-------|------|
| `dev-status.sh` | DB・Backend・Frontend・Alembicの一括状態チェック |
| `db-inspect.sh` | テーブル一覧・行数・マイグレーション状態の詳細表示 |
| `dev-reset.sh` | ワンショット環境リセット（安全ガード付き） |
| Claude Hooks | モデルファイル変更時にAlembicリマインダーを自動表示 |

これらを整備する前は、「DBにテーブルが存在しない」「マイグレーションが未適用」といった環境起因のエラーに対し、原因特定に無駄な時間を費やしていた。整備後は作業開始時に `dev-status.sh` を実行するだけで環境の健全性が即座に分かる。

DD-025のマスタデータ全量シード（14テーブル・500+レコード）も同じ文脈にある。冪等なシードスクリプトにより、DD間で「前のDDで投入したデータが前提」という暗黙の依存が解消された。

**教訓**: AI主導開発では「AIが環境を自己診断できること」が生産性の前提条件。見えない環境で作業させると、原因不明のエラーに時間を浪費する。

### 12. ドキュメントは「書く」だけでなく「引く」設計が必要

Phase 1 で仕様書を作り、Phase 2 で画面を量産した。しかし実装フェーズが進むにつれ、仕様書への**アクセスパターン**が多様化し、仕様書だけでは「引きにくい」場面が増えた。

DD-027〜DD-031で3種の**逆引きビュー**を整備した:

| ビュー | アクセスパターン | 根拠DD |
|-------|----------------|--------|
| ER図（A5M2形式） | テーブル間の関係を視覚的に確認 | DD-027 |
| 業務フロー図（Mermaid） | 画面間のデータフロー・月次サイクル | DD-028 |
| 計算サマリー（逆引き表） | 特定の計算式の全体像を俯瞰 | DD-030, DD-031 |

仕様書は「正規化された情報ストア」であり、計算式・ルール・定数を一意に定義する場所として正しく機能している。しかし「この計算の全体像は？」「このテーブルはどこから参照される？」という問いに対しては、仕様書を横断検索する必要があり非効率だった。逆引きビューはこの問題を解決する「非正規化インデックス」である。

**教訓**: 仕様書は正規化して書き、逆引きビューは非正規化して読む。DB設計と同じ原則がドキュメント設計にも適用できる。

---

## 新機能実装で得られた気付き（DD-032〜DD-036）

### 13. PoC は「作って捨てる」ではなく「昇格する」設計にせよ

DD-006 で作成した TanStack Table ベースの売上グリッド PoC が、DD-034 で本実装に昇格した。PoCの段階で以下を意識していたため、昇格がスムーズだった:

- セルコンポーネント（TextCell, NumberCell等）を**独立した再利用可能な部品**として分離
- `SalesRecord` 型をAPI非依存で定義
- controlled コンポーネント設計（`data` + `onDataChange` props）

一方で、PoCにはなかった要素（dirty tracking、APIとの接続、バリデーション、編集ダイアログ）の追加は必要だった。重要なのは、PoCが「概念検証」としてだけでなく「本実装の骨格」として設計されていたことだ。

**教訓**: PoCは「動くか確認する」だけでなく「本実装に昇格できる構造」で書くべき。特に**コンポーネント分割と型定義**が昇格のしやすさを決める。PoCを捨てて作り直す前提で書くと、検証で得た知見がコードとして残らない。

### 14. 仕様書にない「暗黙の業務ルール」は実装フェーズで必ず現れる

Phase 1 の仕様書はコードから業務ルールを抽出した。しかし実装フェーズで、**コードに書かれていない暗黙のルール**が複数発見された。

| 発見 | 内容 | 根拠DD |
|------|------|--------|
| 白流れの表現 | 仕様書の `is_paid` では「キャンセル」と「未入金」を区別できない。`is_nagare` を独立カラムとして追加 | DD-033 |
| 仮締め→本締め | 締め処理が2段階であることは仕様書に未記載。readOnly制御が仮締めワークフローを破壊するCriticalバグに | DD-036 Round 4 |
| 未文書化バリデーション | 売上データの入力ルール7件が仕様書に存在しない | DD-033 Phase 0 |

これは #7（バリデーション見落とし）の発展形だが、より根本的な問題を示している。#7 は「コードに書かれていたルールの抽出漏れ」だったが、ここで言う暗黙ルールは**コードにも明示的に書かれていない運用慣行**である。仕様書はコードの真実を抽出するツールとしては高精度だが、コードに書かれていない真実は抽出できない。

**教訓**: 仕様書は「コードに書かれた業務ルール」の抽出には優れるが、「運用で暗黙に成立しているルール」は守備範囲外。実装フェーズではドメインエキスパートへの確認工程を明示的に設けるべき。

### 15. DA批判レビューは「ラウンドを重ねるほど深い問題を見つける」

DD-036で5ラウンドのDA批判レビューを実施し、計34件のバグを段階的に発見した。各ラウンドで**分析の軸を変えた**ことが、深い問題の発見に繋がった。

| ラウンド | 分析軸 | 発見 | 代表的なバグ |
|---------|-------|------|------------|
| Round 1 | 横断分析（型・API整合性） | 致命1, 高4, 中2 | Excel export の Pydantic dict アクセスエラー |
| Round 2 | 全行精読 | 高2, 中2, 低1 | 売上種別ドロップダウン不一致 |
| Round 3 | 動線トレース図 | 致命1, 高3, 中4 | 部分失敗後のstate不整合 |
| Round 4 | ビジネスフロー検証 | 致命1, 高2 | 仮締め→本締めワークフロー破壊 |
| Round 5 | リグレッション検証 | 致命1, 中5 | Round 4修正で生まれたガード漏れ |

注目すべきは、Round 3 以降で**致命的（Critical）バグが毎回見つかっている**ことだ。Round 1〜2 の表面的なチェックでは「修正完了」に見えても、動線トレース図やビジネスフロー検証という異なる軸で見ると、より深い構造的問題が現れる。

また、Round 4 の修正が Round 5 で新たなバグを生んでいる点も重要だ。修正→検証のサイクルを1回で止めてはいけない。

**教訓**: DA批判レビューは1回で終わらせず、**分析軸を変えて繰り返す**べき。特に修正を入れた後のリグレッション検証は必須。「もう問題ないだろう」という感覚は、Round 1〜2 で発見できる表面的バグが消えた時点で生まれやすい偽の安心感である。

---

## 今後追記予定

- 仕様書→テスト仕様書の生成で得られた気付き
- 計算結果の突合で発見した問題
- 他プロジェクトへの適用で判明した汎用化の課題
