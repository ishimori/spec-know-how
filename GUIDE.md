# レガシーコードから仕様を抽出する手順

このガイドは「何を・どの順番で把握すればいいか」を示します。
各 Step の終わりに Gate チェックリストで「次に進んでいいか」を確認してください。

---

## 全体の流れ

```mermaid
flowchart LR
    S1["Step 1\n対象を把握する"]
    S2["Step 2\nDB・データモデル"]
    S3["Step 3\n画面・UI"]
    S4["Step 4\n業務ロジック"]
    S5["Step 5\n非機能要件"]
    S6["Step 6\nQA スキル"]

    G1{Gate 1}
    G2{Gate 2}
    G3{Gate 3}
    G4{Gate 4}
    G5{Gate 5}
    G6{Gate 6}

    S1 --> G1 --> S2 & S3
    S2 --> G2 --> S4
    S3 --> G3 --> S4
    S4 --> G4 --> S5
    S5 --> G5 --> S6
    S6 --> G6

    style G1 fill:#f9f,stroke:#333
    style G2 fill:#f9f,stroke:#333
    style G3 fill:#f9f,stroke:#333
    style G4 fill:#f9f,stroke:#333
    style G5 fill:#f9f,stroke:#333
    style G6 fill:#f9f,stroke:#333
```

Step 2〜3 は並行して進められます。Gate で情報が揃っているか確認してから次に進んでください。

> **注**: このガイドの Gate 1〜6 は `gates/` フォルダのチェックリストに対応します。`manuals/` 内にも各ステップに Gate がありますが、番号体系が異なります（マニュアルは独自の5ステップ構成）。

---

## Step 1: 対象を把握する

まず「何があるか」の全体像を掴みます。コードを深く読む前の段階です。

### やること

**コードベースの定量把握**
- ディレクトリ構造を確認する（フォルダの役割を把握する）
- 技術スタックを確認する（言語・フレームワーク・主要ライブラリ）
- LOC（行数）とファイル数を確認する

```bash
# 技術スタックの確認例
find . -name "package.json" -o -name "requirements.txt" -o -name "pom.xml" | head -20
find . -name "*.py" | wc -l   # Pythonファイル数
```

**既存ドキュメントの棚卸し**
- README、設計書、仕様書、コメントを確認する
- 「信頼できるドキュメント」と「古くて怪しいドキュメント」を分ける
- 実際のコードと食い違っているドキュメントを見つけた場合はメモしておく

### ポイント

- この段階では深く読まない。「何があるか」だけ把握する
- 既存ドキュメントが充実していても、コードと照合するまで信頼しない
- 「思ったより大きい / 小さい」という感覚を掴む

**→ [Gate 1: 初回調査チェックリスト](gates/01_initial_survey.md)**

---

## Step 2: DB・データモデルを取得する

データ構造はシステムの骨格です。業務ロジックを読む前に把握しておくと理解が速くなります。

### やること

**スキーマの取得**

優先順位：ERD・設計書 > マイグレーションファイル > DDL > コードのモデル定義

```bash
# マイグレーションファイルの確認例
ls migrations/ alembic/versions/ db/migrate/
# モデル定義の確認例（Django/SQLAlchemy）
grep -r "class.*Model" src/ --include="*.py" -l
```

**主要テーブルの整理**

| テーブル名 | 用途 | 備考 |
|-----------|------|------|
| （例）users | ユーザー管理 | ロール情報あり |
| （例）orders | 注文データ | 論理削除あり |

**マスタデータの把握**

コードではわからないことがある。できれば本番 DB のマスタデータダンプ（個人情報除外）を入手する。

> **教訓**: マスタデータの具体値が不明なまま実装を進めると、識別子の不一致（日本語 vs 英語コード等）が後から横断バグとして現れる。詳細は [references/lessons_learned.md](references/lessons_learned.md) の「うまくいかなかった点 #2」を参照。

### ポイント

- ストアドプロシージャ・ビューも忘れずに確認する
- 論理削除カラム（`deleted_at`、`is_deleted` 等）は業務ロジックに影響する
- テーブル数が多い場合はコアテーブル（最も参照される）から優先する

**→ [Gate 2: DB情報取得チェックリスト](gates/02_database.md)**

---

## Step 3: 画面・UI を把握する

どんな画面があり、何ができるかを把握します。

### やること

**画面一覧の作成**

| 画面名 | URL/パス | 主な機能 | 対象ロール |
|-------|---------|---------|-----------|
| （例）ログイン | /login | 認証 | 全員 |
| （例）ダッシュボード | /dashboard | 集計表示 | 管理者 |

**画面遷移の把握**

主要な操作フロー（申請→承認、入力→確認→完了 等）を図または文章で整理する。

**権限・ロール制御の確認**

- どのロールがどの画面を見られるか
- 同じ画面でもロールによって表示項目が変わる場合はその条件を把握する

> **教訓**: 画面仕様を抽出するとき、「画面の機能（何ができるか）」と「UIの構成（どう見せるか）」を分けて記録する。フレームワーク移行の場合、前者は忠実に移植し、後者は移行先に合わせて再設計するのが正しい。詳細は [references/lessons_learned.md](references/lessons_learned.md) の「気付き #8」を参照。

### ポイント

- submit/save 関数は UI 層でもビジネスロジックを持つことがある。必ず確認する
- モーダル・ダイアログも「画面」として一覧化する
- 画面数が多い場合はコアフロー（最もよく使われる業務フロー）から優先する

**→ [Gate 3: 画面把握チェックリスト](gates/03_screens.md)**

---

## Step 4: 業務ロジックを抽出する

計算式・バリデーション・ワークフロー制御など、ビジネスルールを仕様として文書化します。

### やること

**抽出対象を絞る**

全コードを均等に読もうとしない。以下を優先する：
- コアとなる計算ロジック（料金計算、集計処理 等）
- バリデーションルール（入力制約、業務上の制約）
- 状態遷移（ワークフロー、ステータス管理）
- 外部システム連携（API 呼び出し、ファイル入出力）

**信頼度を付与する**

抽出した仕様には信頼度を付与します：

| 信頼度 | 意味 | 使い方 |
|--------|------|-------|
| `High` | コードと照合済み、根拠明確 | そのまま使える |
| `Medium` | 一部照合済み、一部推測 | 注意して使う |
| `Low` | 根拠不足、未検証 | 使う前に調査が必要 |
| `Conflicting` | コードとドキュメントで矛盾 | 解消するまで使えない |

**コードと仕様を突合する（できる場合）**

仕様書の記述とコードを照合して信頼度を上げる。AST 解析や Grep による機械的な突合が有効。

> **教訓**: 「計算ロジック」だけが業務ロジックではない。UI 層の submit/save 関数に埋まったバリデーション 12 条件が丸ごと見落とされたケースがある。詳細は [references/lessons_learned.md](references/lessons_learned.md) の「気付き #7」を参照。

### ポイント

- 仕様書は AI に書かせると AI が読みやすい構造になる（AI 自身が検索・引用できる）
- BR-001 のような採番ルールを決めておくと QA 時に参照しやすい
- 「コードに書かれていない暗黙のルール」はコードからは抽出できない。ドメインエキスパートへの確認工程を設ける

**→ [Gate 4: 業務ロジック抽出チェックリスト](gates/04_business_logic.md)**

---

## Step 5: 非機能要件を確認する

認証・ログ・パフォーマンス・セキュリティなど、機能以外の要件を把握します。

### やること

業務ロジックを追うと非機能要件は後回しになりがちです。意識的に確認してください。

**確認カテゴリ**

- **認証・認可**: どのロールが何を操作できるか（画面レベル・データレベル）
- **ログ**: 何をログに残しているか、監査目的のログはあるか
- **パフォーマンス**: SLA・応答時間の要件はあるか、N+1 クエリなど既知の問題はあるか
- **セキュリティ**: SQLインジェクション対策、XSS対策、CSRF対策の有無
- **バックアップ・リカバリ**: どう運用されているか

> **教訓**: 個別の機能 DD を追うと非機能要件が抜ける。NFR は独立したトラックとして扱い、意識的に確認しないと漏れる。

**→ [Gate 5: 非機能要件確認チェックリスト](gates/05_nfr.md)**

---

## Step 6: QA スキルを作る

仕様情報が揃ったら、「この機能の仕様は？」という質問に即答できる QA スキルを作ります。

### QA スキルとは

コードを読まずに仕様を確認できる仕組みです。仕様書のインデックスを持ち、質問をキーワードで仕様書にマッピングし、根拠付きで回答します。

作り方は [how-to/qa-skill.md](how-to/qa-skill.md) を参照してください。

**→ [Gate 6: QA 準備完了チェックリスト](gates/06_qa_ready.md)**

---

## 参考資料

| 資料 | 内容 |
|------|------|
| [references/lessons_learned.md](references/lessons_learned.md) | 44DD 以上の実践から得た教訓 |
| [manuals/](manuals/) | 包括マニュアル（「なぜ・どうやるか」の詳細 + ゲート + アンチパターン） |
| [how-to/qa-skill.md](how-to/qa-skill.md) | QA スキルの作り方 |
